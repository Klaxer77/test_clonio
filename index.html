<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Snake Smooth Multiplayer</title>
  <style>
    html,body{
      margin:0;padding:0;
      overflow:hidden;
      font-family:Arial,sans-serif;
      background: linear-gradient(135deg, #1a1a1a 0%, #111 100%);
      color:white;
      height:100%;
    }

    /* –≤–∞–∂–Ω–æ –¥–ª—è iOS: —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ —Å–∫—Ä–æ–ª–ª–∞/–∑—É–º–æ–≤ –æ—Ç –∂–µ—Å—Ç–æ–≤ */
    body{ position:fixed; inset:0; }

    canvas{
      display:block;
      outline:none;
      touch-action:none;
    }

    #menu{
      position:fixed;inset:0;
      display:flex;align-items:center;justify-content:center;flex-direction:column;
      background: rgba(0,0,0,0.82);
      gap:14px;text-align:center;padding:24px;box-sizing:border-box;
      z-index:30;
    }
    button{font-size:24px;padding:15px 40px;cursor:pointer;border:none;background:lime;color:black;border-radius:10px;}
    button:hover{background:#7CFF7C;}

    .hud{
      position:fixed;left:12px;top:10px;z-index:25;
      font-size:14px;opacity:.85;user-select:none;pointer-events:none;
      text-shadow:0 1px 2px rgba(0,0,0,.6);
      line-height:1.35;white-space:pre;
    }

    /* ===== MOBILE UI (–ù–ï –¢–†–û–ì–ê–ï–¢ –î–ï–°–ö–¢–û–ü) ===== */
    #touchUI{
      position:fixed;
      inset:0;
      z-index:20;
      display:none;          /* –≤–∫–ª—é—á–∞–µ–º —Ç–æ–ª—å–∫–æ –Ω–∞ —Ç–∞—á */
      pointer-events:none;
      touch-action:none;
    }

    #joyWrap{
      position:absolute;
      left:16px;
      bottom:18px;
      width:120px;
      height:120px;
      pointer-events:auto;
      touch-action:none;
    }
    #joyBase{
      width:100%;
      height:100%;
      border-radius:999px;
      background:rgba(255,255,255,0.10);
      border:1px solid rgba(255,255,255,0.18);
      backdrop-filter: blur(4px);
      position:relative;
    }
    #joyKnob{
      position:absolute;
      left:50%;
      top:50%;
      width:48px;
      height:48px;
      margin-left:-24px;
      margin-top:-24px;
      border-radius:999px;
      background:rgba(255,255,255,0.22);
      border:1px solid rgba(255,255,255,0.25);
      box-shadow:0 8px 18px rgba(0,0,0,.35);
      transform:translate(0,0);
      will-change:transform;
    }

    /* —Å–ø—Ä–∞–≤–∞ –æ—Å—Ç–∞–≤–∏–ª–∏ —Ç–æ–ª—å–∫–æ —É—Å–∫–æ—Ä–µ–Ω–∏–µ */
    #btnWrap{
      position:absolute;
      right:18px;
      bottom:28px;
      display:flex;
      flex-direction:column;
      gap:12px;
      pointer-events:auto;
      touch-action:none;
    }
    #boostBtn{
    background: radial-gradient(circle at 30% 30%, rgba(255,224,102,0.85), rgba(245,196,0,0.85)) !important;
    color:#111 !important;
    opacity:0.9;
    -webkit-appearance: none;
    appearance: none;
    background-clip: padding-box;
    }
    .touchBtn{
      width:150px;
      height:64px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(255,255,255,0.12);
      color:#fff;
      font-size:16px;
      font-weight:600;
      letter-spacing:.2px;
      box-shadow:0 10px 20px rgba(0,0,0,.35);
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .boostBtn{
    width:72px;
    height:72px;
    border-radius:999px;

    display:flex;
    align-items:center;
    justify-content:center;

    font-size:32px;
    font-weight:700;

    background: radial-gradient(circle at 30% 30%, #ffe066, #f5c400);
    color:#111;

    border:1px solid rgba(255,255,255,0.25);
    box-shadow:
        0 10px 22px rgba(0,0,0,.35),
        inset 0 2px 4px rgba(255,255,255,.35);

    user-select:none;
    -webkit-tap-highlight-color: transparent;
    }
    .boostBtn:active{
    transform: scale(0.96);
    box-shadow:
        0 6px 14px rgba(0,0,0,.35),
        inset 0 1px 3px rgba(255,255,255,.35);
    }

    .touchBtn:active{ transform: translateY(1px); }

    @media (pointer:coarse){
      .hud{top:8px;left:10px;font-size:12px;opacity:.78;}
    }
  </style>
</head>
<body>
  <div id="menu">
    <h1>üêç Snake</h1>
    <button id="playBtn">–ò–≥—Ä–∞—Ç—å</button>
  </div>

  <div id="hud" class="hud" style="display:none"></div>
  <canvas id="game" tabindex="0"></canvas>

  <!-- MOBILE CONTROLS (—Å–∫—Ä—ã—Ç–æ –Ω–∞ –ü–ö) -->
  <div id="touchUI" aria-hidden="true">
    <div id="joyWrap">
      <div id="joyBase">
        <div id="joyKnob"></div>
      </div>
    </div>
    <div id="btnWrap">
      <button id="boostBtn" class="boostBtn">‚ö°</button>
    </div>
  </div>

<script>
/*
  –ò–ó–ú–ï–ù–ï–ù–ò–Ø:
  - –£–±—Ä–∞–Ω–∞ –∫–Ω–æ–ø–∫–∞ "–ø–æ–ª–Ω—ã–π —ç–∫—Ä–∞–Ω" (–Ω–∞ iPhone —ç—Ç–æ –ø–æ—á—Ç–∏ –≤—Å–µ–≥–¥–∞ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–æ—Ä–º–∞–ª—å–Ω–æ).
  - –ù–∞ –º–æ–±–∏–ª–∫–µ –∏–≥—Ä–∞ —Å–∞–º–∞ –∑–∞–Ω–∏–º–∞–µ—Ç –≤–µ—Å—å —ç–∫—Ä–∞–Ω —á–µ—Ä–µ–∑ visualViewport.
  - –£–≤–µ–ª–∏—á–µ–Ω —Ä–∞–∑–º–µ—Ä –∑–º–µ–π–∫–∏ –¢–û–õ–¨–ö–û –Ω–∞ —Ç–∞—á-—É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞—Ö.
  - –ü–ö-–≤–µ—Ä—Å–∏—è –ø–æ –ª–æ–≥–∏–∫–µ/—É–ø—Ä–∞–≤–ª–µ–Ω–∏—é –Ω–µ –º–µ–Ω—è–µ—Ç—Å—è.
*/

const WORLD_W = 3000, WORLD_H = 3000;
const SEGMENT = 30;
const ROOM_ID = "room1";

const CLIENT_SPEED = 4;

/* ===== server speed model (match server!) ===== */
const SERVER_TICK_SEC = 0.025;
const SERVER_SPEED = 7;
const SERVER_BOOST_MULT = 1.8;

const TOUCH_GAIN = 5.2;      // –±—ã–ª–æ —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏ ~9
const TOUCH_TAU_MS = 34;    // –º—è–≥—á–µ

const SPEED_BASE_PX_S  = SERVER_SPEED / SERVER_TICK_SEC;
const SPEED_BOOST_PX_S = (SERVER_SPEED * SERVER_BOOST_MULT) / SERVER_TICK_SEC;

let predDirUnit = {x:1, y:0};
let ws=null, playerId=null, players={}, foods=[], cameraX=0, cameraY=0;
let dir = {x:1, y:0}, dead=false;

/* —Ä–µ–∂–∏–º—ã –≤–≤–æ–¥–∞ */
let useMouse = false;     // –ü–ö: M / –¨
let useTouch = false;     // –º–æ–±: –∞–≤—Ç–æ

let serverBoosting = false;
const keysDown = new Set();

/* axis priority without key-repeat jitter */
let lastAxisX = 1;
let lastAxisY = -1;

const menu=document.getElementById("menu"),
      playBtn=document.getElementById("playBtn"),
      canvas=document.getElementById("game"),
      hud=document.getElementById("hud"),
      ctx=canvas.getContext("2d");

/* mobile ui refs */
const touchUI = document.getElementById("touchUI");
const joyWrap = document.getElementById("joyWrap");
const joyKnob = document.getElementById("joyKnob");
const boostBtn = document.getElementById("boostBtn");

const isTouchDevice =
  (window.matchMedia && window.matchMedia("(pointer:coarse)").matches) ||
  ("ontouchstart" in window) ||
  (navigator.maxTouchPoints > 0);

function wsUrl(path){
  const proto = (location.protocol === "https:") ? "wss" : "ws";
  return `${proto}://${location.host}${path}`;
}

function clamp01(v){ return Math.max(-1, Math.min(1, v)); }
function lerp(a,b,t){ return a + (b-a)*t; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function normAngle(a){
  while(a > Math.PI) a -= Math.PI*2;
  while(a < -Math.PI) a += Math.PI*2;
  return a;
}

/* =========================
   SCALE (–ü–ö –Ω–µ —Ç—Ä–æ–≥–∞–µ–º)
========================= */
const DESKTOP_SNAKE_SCALE = 1.35;
const MOBILE_SNAKE_SCALE  = 0.60; // <-- —Ç—É—Ç –º–æ–∂–µ—à—å –ø–æ–¥–Ω—è—Ç—å/–æ–ø—É—Å—Ç–∏—Ç—å –ø–æ–¥ —Å–µ–±—è

let SNAKE_SCALE = DESKTOP_SNAKE_SCALE;   // –±—É–¥–µ—Ç –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ –Ω–∞ —Å—Ç–∞—Ä—Ç–µ –Ω–∞ –º–æ–±–∏–ª–∫–µ
let GRID_STEP = Math.round(SEGMENT * 2.4);

/* =========================
   FPS METER
========================= */
let fps = 60;
let lastFpsTs = performance.now();
let frames = 0;
let lowDetail = false;

function updateFpsOnRenderedFrame(timeMs){
  frames++;
  const dt = timeMs - lastFpsTs;
  if(dt >= 500){
    fps = Math.round((frames * 1000) / dt);
    frames = 0;
    lastFpsTs = timeMs;

    lowDetail = fps < 45;
    GRID_STEP = Math.round(SEGMENT * (lowDetail ? 3.2 : 2.4));
  }
}

/* =========================
   RTT ping/pong
========================= */
let rtt = 60;
let rttTimer = null;

function startRttPing(){
  if(rttTimer) clearInterval(rttTimer);
  rttTimer = setInterval(()=>{
    if(!ws || ws.readyState !== 1) return;
    ws.send(JSON.stringify({type:"ping", t: performance.now()}));
  }, 800);
}

/* =========================
   ADAPTIVE FPS CAP + SNAP TIMING
========================= */
const TARGET_CAP = 75;
const SERVER_TICK_MS = 25;
const PLAYERS_SEND_EVERY = 1;
const SNAP_INTERVAL_MS = SERVER_TICK_MS * PLAYERS_SEND_EVERY;
const MIN_INTERP_MS = Math.max(55, Math.ceil(SNAP_INTERVAL_MS * 2.2));

const rafMeter = { lastTs: null, samples: [], maxSamples: 90, hz: 60 };

function updateRafHz(ts){
  if(rafMeter.lastTs == null){ rafMeter.lastTs = ts; return; }
  const dt = ts - rafMeter.lastTs;
  rafMeter.lastTs = ts;
  if(dt <= 0) return;

  const instHz = 1000 / dt;
  if(instHz < 10 || instHz > 400) return;

  rafMeter.samples.push(instHz);
  if(rafMeter.samples.length > rafMeter.maxSamples) rafMeter.samples.shift();

  const a = rafMeter.samples.slice().sort((x,y)=>x-y);
  const mid = a.length >> 1;
  const med = a.length ? (a.length % 2 ? a[mid] : (a[mid-1]+a[mid])/2) : 60;

  const snap = (v) => {
    const presets = [50, 60, 75, 90, 100, 120, 144, 165, 180, 240];
    let best = v, bestD = 1e9;
    for(const p of presets){
      const d = Math.abs(v - p);
      if(d < bestD){ bestD = d; best = p; }
    }
    return (bestD <= 3.0) ? best : v;
  };
  rafMeter.hz = snap(med);
}

let capHz = 60;
function getCapHz(){
  return Math.min(rafMeter.hz || 60, TARGET_CAP);
}

/* =========================
   CANVAS SIZE (iOS visualViewport)
   –ü–ö –Ω–µ –ª–æ–º–∞–µ–º: –æ–±—ã—á–Ω—ã–π innerWidth/innerHeight
========================= */

let VIEW_W = innerWidth;
let VIEW_H = innerHeight;

function fitCanvas(){
  const vv = window.visualViewport;

  const w = vv ? Math.round(vv.width)  : innerWidth;
  const h = vv ? Math.round(vv.height) : innerHeight;

  VIEW_W = w;
  VIEW_H = h;

  if(isTouchDevice){
    const dpr = Math.max(1, window.devicePixelRatio || 1);

    canvas.style.width = w + "px";
    canvas.style.height = h + "px";

    canvas.width  = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);

    // –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ = CSS-–ø–∏–∫—Å–µ–ª–∏
    ctx.setTransform(dpr,0,0,dpr,0,0);
  } else {
    canvas.width = w;
    canvas.height = h;
    ctx.setTransform(1,0,0,1,0,0);
  }
}
window.addEventListener("resize", fitCanvas);
window.visualViewport?.addEventListener("resize", fitCanvas);
window.visualViewport?.addEventListener("scroll", fitCanvas);

/* =========================
   RENDER HELPERS (–ø–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –æ—Ç SNAKE_SCALE)
========================= */
function bodyWidth(){ return SEGMENT * 0.95 * SNAKE_SCALE; }
function headRadius(){ return bodyWidth() * 0.50; }
function eyeWhiteR(){ return headRadius() * 0.38; }
function eyePupilR(){ return eyeWhiteR() * 0.45; }
function pupilShift(){ return eyeWhiteR() * 0.35; }

/* =========================
   RENDER SMOOTH (DT-AWARE)
========================= */
const renderCache = {};
function smoothSnake(id, targetSnake, alpha){
  if(!targetSnake || targetSnake.length === 0) return targetSnake;

  const prev = renderCache[id];
  if(!prev || prev.length === 0){
    renderCache[id] = targetSnake.map(p => ({x:p.x, y:p.y}));
    return renderCache[id];
  }

  const n = targetSnake.length;
  const out = new Array(n);
  for(let i=0;i<n;i++){
    const tp = targetSnake[i];
    const pp = prev[i] || prev[prev.length - 1] || tp;
    out[i] = { x: lerp(pp.x, tp.x, alpha), y: lerp(pp.y, tp.y, alpha) };
  }

  renderCache[id] = out;
  return out;
}

/* =========================
   SNAPSHOTS (OTHERS)
========================= */
const snapshots = {};
const SNAP_MAX = 18;

function pushSnapshot(id, pl){
  const t = performance.now();
  const q = snapshots[id] || (snapshots[id] = []);
  q.push({
    t,
    snake: (pl.snake || []).map(p => ({x:p.x, y:p.y})),
    boost: !!pl.boost,
    color: pl.color || "white"
  });
  while(q.length > SNAP_MAX) q.shift();
}

function cleanupSnapshots(){
  for(const id in snapshots){
    if(!players[id]) delete snapshots[id];
  }
}

function sampleInterpSnake(id, renderTime){
  const q = snapshots[id];
  if(!q || q.length === 0) return null;
  if(q.length === 1) return {snake: q[0].snake, boost:q[0].boost, color:q[0].color};

  let a = null, b = null;
  for(let i=0;i<q.length-1;i++){
    if(q[i].t <= renderTime && renderTime <= q[i+1].t){
      a = q[i]; b = q[i+1]; break;
    }
  }

  if(!a || !b){
    if(renderTime < q[0].t) return {snake:q[0].snake, boost:q[0].boost, color:q[0].color};
    return {snake:q[q.length-1].snake, boost:q[q.length-1].boost, color:q[q.length-1].color};
  }

  const dt = (b.t - a.t);
  const k = dt <= 1 ? 0 : clamp01((renderTime - a.t) / dt);

  const n = Math.max(a.snake.length, b.snake.length);
  if(n === 0) return {snake:[], boost:b.boost, color:b.color};

  const out = new Array(n);
  for(let i=0;i<n;i++){
    const pa = a.snake[i] || a.snake[a.snake.length-1];
    const pb = b.snake[i] || b.snake[b.snake.length-1];
    out[i] = {x: lerp(pa.x, pb.x, k), y: lerp(pa.y, pb.y, k)};
  }

  return {snake: out, boost: b.boost, color: b.color};
}

/* =========================
   ME: LOCAL PREDICTION
========================= */
let meBaseSnake = null;
let meBaseHead  = null;
let mePredHead  = null;
let meLastPredTs = null;
let meBaseBoost = false;

function getMyHead(){
  if(mePredHead) return mePredHead;
  if(meBaseHead) return meBaseHead;
  const me = players[playerId];
  if(me?.snake?.[0]) return me.snake[0];
  return null;
}

/* =========================
   FOOD SPAWN ANIM (light)
========================= */
const foodBirth = new Map();
const FOOD_POP_MS = 380;

function foodKey(f){
  const x = (f && typeof f.x === "number") ? f.x : 0;
  const y = (f && typeof f.y === "number") ? f.y : 0;
  const k = f?.kind || "";
  const c = f?.color || "";
  const s = (typeof f?.size === "number") ? f.size : 1;
  return `${x}|${y}|${k}|${c}|${s}`;
}

function markFoodBirths(newFoods, timeMs){
  for(const f of (newFoods || [])){
    if(f?.kind !== "corpse") continue;
    const key = foodKey(f);
    if(!foodBirth.has(key)) foodBirth.set(key, timeMs);
  }

  if(!markFoodBirths._nextClean) markFoodBirths._nextClean = timeMs + 2000;
  if(timeMs < markFoodBirths._nextClean) return;
  markFoodBirths._nextClean = timeMs + 2000;

  const cutoff = timeMs - 8000;
  for(const [k, born] of foodBirth.entries()){
    if(born < cutoff) foodBirth.delete(k);
  }
}

function easeOutCubic(t){
  t = Math.max(0, Math.min(1, t));
  return 1 - Math.pow(1 - t, 3);
}

/* =========================
   CONTROL + STEERING
========================= */
let lastSent = 0;
let lastDirSent = {x:1, y:0};
let wantDirUnit = {x:1, y:0};

const SEND_EPS2 = 0.00025;
const SEND_MIN_MS = 20;
const SEND_IDLE_MS = 90;

function sendDirection(nx, ny){
  if(!ws) return;
  if(dead) return;
  if(ws.readyState !== 1) return;

  const now = performance.now();
  const dx = nx - lastDirSent.x;
  const dy = ny - lastDirSent.y;
  const changed = (dx*dx + dy*dy) > SEND_EPS2;

  if(!changed && (now - lastSent) < SEND_IDLE_MS) return;
  if((now - lastSent) < SEND_MIN_MS) return;

  lastSent = now;
  lastDirSent = {x:nx, y:ny};
  ws.send(JSON.stringify({direction: {x: nx, y: ny}}));
}

function setDirUnit(nx, ny){
  const l = Math.hypot(nx, ny) || 1;
  nx /= l; ny /= l;
  wantDirUnit = {x:nx, y:ny};
  dir = {x: nx*CLIENT_SPEED, y: ny*CLIENT_SPEED};
  sendDirection(nx, ny);
}

let heading = 0;       // radians
let angVel = 0;        // rad/s

// –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞-—Ä—É–ª—å (–ü–ö)
const TURN_BASE = 3.6;
const TURN_FAST = 5.2;
const TURN_SLOW = 2.2;
const TURN_TAU_MS = 35;
const TURN_STOP_TAU_MS = 55;

// –º—ã—à—å/—Ç–∞—á (—Ä—É–ª—å)
const MOUSE_GAIN = 9.0;
const MOUSE_TAU_MS = 22;
const MOUSE_DEADZONE_RAD = 0.010;

let mouseTargetHeading = null;
let touchTargetHeading = null;

function initHeadingFromVector(v){
  heading = Math.atan2(v.y, v.x);
  angVel = 0;
  mouseTargetHeading = heading;
  touchTargetHeading = heading;
}

function applySteeringKeyboard(dtMs){
  const left  = keysDown.has("a");
  const right = keysDown.has("d");
  const fast  = keysDown.has("w");
  const slow  = keysDown.has("s");

  let turn = 0;
  if(left && !right) turn = -1;
  else if(right && !left) turn = 1;
  else if(left && right) turn = lastAxisX;

  let turnRate = TURN_BASE;
  if(fast && !slow) turnRate = TURN_FAST;
  if(slow && !fast) turnRate = TURN_SLOW;

  const targetAngVel = turn * turnRate;

  const tau = (turn !== 0) ? TURN_TAU_MS : TURN_STOP_TAU_MS;
  const k = 1 - Math.exp(-dtMs / tau);
  angVel = angVel + (targetAngVel - angVel) * k;

  heading += angVel * (dtMs / 1000);
  setDirUnit(Math.cos(heading), Math.sin(heading));
}

function applySteeringPointer(dtMs){
  const target = useTouch ? touchTargetHeading : mouseTargetHeading;
  if(target == null) return;

  const err = normAngle(target - heading);
  const maxVel = TURN_FAST;

  const gain = useTouch ? TOUCH_GAIN : MOUSE_GAIN;
  const tau  = useTouch ? TOUCH_TAU_MS : MOUSE_TAU_MS;

  let targetAngVel = 0;
  if(Math.abs(err) > MOUSE_DEADZONE_RAD){
  targetAngVel = clamp(err * gain, -maxVel, +maxVel);
  }

const k = 1 - Math.exp(-dtMs / tau);

  angVel = angVel + (targetAngVel - angVel) * k;

  heading += angVel * (dtMs / 1000);
  setDirUnit(Math.cos(heading), Math.sin(heading));
}

function applySteering(dtMs){
  if(!ws || ws.readyState !== 1) return;
  if(dead) return;

  if(useTouch) applySteeringPointer(dtMs);
  else if(useMouse) applySteeringPointer(dtMs);
  else applySteeringKeyboard(dtMs);
}

/* heartbeat */
let inputTimer = null;
let lastInputTs = null;

function startInputHeartbeat(){
  if(inputTimer) clearInterval(inputTimer);
  lastInputTs = performance.now();

  inputTimer = setInterval(()=>{
    if(!ws || ws.readyState !== 1) return;
    if(dead) return;

    const now = performance.now();
    let dt = now - lastInputTs;
    lastInputTs = now;

    if(dt < 1) dt = 1;
    if(dt > 40) dt = 40;

    applySteering(dt);
  }, 16);
}

function sendBoost(state){
  if(!ws) return;
  if(ws.readyState !== 1) return;
  if(state === serverBoosting) return;
  serverBoosting = state;
  ws.send(JSON.stringify({boost: state}));
}

/* =========================
   CAMERA
========================= */
let camHX = null, camHY = null;
const CAM_SMOOTH = 0.18;

function updateCamera(renderMeSnake){
  if(!renderMeSnake || renderMeSnake.length === 0) return;
  const h = renderMeSnake[0];
  if(camHX === null){ camHX = h.x; camHY = h.y; }
  camHX = camHX + (h.x - camHX) * CAM_SMOOTH;
  camHY = camHY + (h.y - camHY) * CAM_SMOOTH;
  cameraX = camHX - VIEW_W/2;
  cameraY = camHY - VIEW_H/2;
}

/* =========================
   DRAW HELPERS
========================= */
function drawSnakeEyes(s, look){
  if(!s || s.length < 2) return;

  const h = s[0];
  const n = s[1];

  let fx = h.x - n.x;
  let fy = h.y - n.y;
  const fl = Math.hypot(fx, fy) || 1;
  fx /= fl; fy /= fl;

  const lx = -fy;
  const ly = fx;

  const cx = h.x - cameraX + SEGMENT/2;
  const cy = h.y - cameraY + SEGMENT/2;

  const HR = headRadius();
  const EWR = eyeWhiteR();
  const EPR = eyePupilR();
  const PS  = pupilShift();

  const side = HR * 0.55;
  const fwd  = HR * 0.20;

  const ex1 = cx + lx*side + fx*fwd;
  const ey1 = cy + ly*side + fy*fwd;
  const ex2 = cx - lx*side + fx*fwd;
  const ey2 = cy - ly*side + fy*fwd;

  let dx = look?.x ?? fx;
  let dy = look?.y ?? fy;
  const dl = Math.hypot(dx, dy) || 1;
  dx /= dl; dy /= dl;

  const lookF = clamp01(dx*fx + dy*fy);
  const lookL = clamp01(dx*lx + dy*ly);

  const pxShiftX = fx*(lookF*PS) + lx*(lookL*PS);
  const pxShiftY = fy*(lookF*PS) + ly*(lookL*PS);

  ctx.save();
  ctx.fillStyle = "white";
  ctx.beginPath(); ctx.arc(ex1, ey1, EWR, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(ex2, ey2, EWR, 0, Math.PI*2); ctx.fill();

  ctx.fillStyle = "black";
  ctx.beginPath(); ctx.arc(ex1 + pxShiftX, ey1 + pxShiftY, EPR, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(ex2 + pxShiftX, ey2 + pxShiftY, EPR, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

function decimate(points, step){
  if(step <= 1) return points;
  const out = [];
  for(let i=0;i<points.length;i+=step) out.push(points[i]);
  if(points.length && out[out.length-1] !== points[points.length-1]) out.push(points[points.length-1]);
  return out;
}

function drawSnakeRibbon(renderSnake, color, boost, isMe, timeMs){
  const base = renderSnake || [];
  if(base.length < 2) return;

  const s = isMe ? base : decimate(base, lowDetail ? 3 : 2);

  const BW = bodyWidth();
  const HR = headRadius();

  if(boost){
    const pulse1 = 0.5 + 0.5*Math.sin(timeMs * 0.022);
    const pulse2 = 0.5 + 0.5*Math.sin(timeMs * 0.017 + 1.2);

    const glowAlpha = lowDetail ? 0.10 : (0.16 + 0.10*pulse1);
    const glowW = BW * ((isMe ? 2.10 : 1.95) + 0.45*pulse2);

    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.strokeStyle = `rgba(255,255,255,${glowAlpha})`;
    ctx.lineWidth = glowW;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.beginPath();
    ctx.moveTo(s[0].x - cameraX + SEGMENT/2, s[0].y - cameraY + SEGMENT/2);
    for(let i=1;i<s.length;i++) ctx.lineTo(s[i].x - cameraX + SEGMENT/2, s[i].y - cameraY + SEGMENT/2);
    ctx.stroke();
    ctx.restore();
  }

  ctx.strokeStyle = color || "white";
  ctx.lineWidth = BW;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  ctx.beginPath();
  ctx.moveTo(s[0].x - cameraX + SEGMENT/2, s[0].y - cameraY + SEGMENT/2);
  for(let i=1;i<s.length;i++) ctx.lineTo(s[i].x - cameraX + SEGMENT/2, s[i].y - cameraY + SEGMENT/2);
  ctx.stroke();

  const head = s[0];
  ctx.fillStyle = color || "white";
  ctx.beginPath();
  ctx.arc(head.x - cameraX + SEGMENT/2, head.y - cameraY + SEGMENT/2, HR, 0, Math.PI*2);
  ctx.fill();

  let look = null;
  if(isMe){
    look = { x: dir?.x ?? 1, y: dir?.y ?? 0 };
  } else {
    const h = s[0], n = s[1];
    look = { x: h.x - n.x, y: h.y - n.y };
  }
  drawSnakeEyes(s, look);
}

/* =========================
   KEYBOARD HELPERS
========================= */
function normKey(k){
  k = (k || "").toLowerCase();
  if(k === "—Ü") return "w";
  if(k === "—Ñ") return "a";
  if(k === "—ã") return "s";
  if(k === "–≤") return "d";
  return k;
}

/* =========================
   DRAW LOOP
========================= */
function draw(ts){
  requestAnimationFrame(draw);
  if(canvas.style.display==="none") return;

  updateRafHz(ts);

  const newCap = getCapHz();
  if(newCap !== capHz) capHz = newCap;
  const stepMs = 1000 / capHz;

  if(draw._lastRafTs == null){
    draw._lastRafTs = ts;
    draw._acc = 0;
  }

  let dt = ts - draw._lastRafTs;
  draw._lastRafTs = ts;

  if(dt > 120) dt = 120;
  draw._acc += dt;

  if(draw._acc < stepMs) return;
  draw._acc -= stepMs;

  const dtFrame = stepMs;
  const timeMs = ts;

  updateFpsOnRenderedFrame(timeMs);
  cleanupSnapshots();

  const gradient = ctx.createLinearGradient(0,0,VIEW_W,VIEW_H);
  gradient.addColorStop(0,"#1a1a1a");
  gradient.addColorStop(1,"#111");
  ctx.fillStyle=gradient;
  ctx.fillRect(0,0,VIEW_W,VIEW_H);


  const baseDelay = Math.min(120, Math.max(20, rtt * 0.35));
  const interpOthers = Math.max(MIN_INTERP_MS, baseDelay);

  const renderPlayers = {};

  /* ===== ME: prediction ===== */
  if(players[playerId] && meBaseSnake && meBaseHead && mePredHead){
    if(meLastPredTs == null) meLastPredTs = timeMs;
    let dtMs = timeMs - meLastPredTs;
    meLastPredTs = timeMs;
    if(dtMs > 60) dtMs = 60;

    const spd = (meBaseBoost ? SPEED_BOOST_PX_S : SPEED_BASE_PX_S);
    const ds = spd * (dtMs / 1000);

    const ux = wantDirUnit?.x ?? 1;
    const uy = wantDirUnit?.y ?? 0;

    const dot = predDirUnit.x*ux + predDirUnit.y*uy;
    if(dot < 0.25){
      predDirUnit.x = ux;
      predDirUnit.y = uy;
    } else {
      const turnAlpha = 1 - Math.exp(-dtMs / 32);
      predDirUnit.x = predDirUnit.x + (ux - predDirUnit.x) * turnAlpha;
      predDirUnit.y = predDirUnit.y + (uy - predDirUnit.y) * turnAlpha;
    }

    const pl = Math.hypot(predDirUnit.x, predDirUnit.y) || 1;
    predDirUnit.x /= pl; predDirUnit.y /= pl;

    mePredHead.x += predDirUnit.x * ds;
    mePredHead.y += predDirUnit.y * ds;

    const dx = mePredHead.x - meBaseHead.x;
    const dy = mePredHead.y - meBaseHead.y;
    const maxLead = 95;
    const dd = Math.hypot(dx, dy);
    if(dd > maxLead){
      const k = maxLead / dd;
      mePredHead.x = meBaseHead.x + dx * k;
      mePredHead.y = meBaseHead.y + dy * k;
    }

    const offX = mePredHead.x - meBaseHead.x;
    const offY = mePredHead.y - meBaseHead.y;

    const n = meBaseSnake.length;
    const predSnake = new Array(n);

    const falloffLen = 6;
    for(let i=0;i<n;i++){
      const t = i / falloffLen;
      const w = (t >= 1) ? 0 : (1 - t) * (1 - t);
      const p = meBaseSnake[i];
      predSnake[i] = { x: p.x + offX * w, y: p.y + offY * w };
    }

    const alphaMe = 1 - Math.exp(-dtFrame / 30);
    const smoothMe = smoothSnake(playerId, predSnake, alphaMe);

    renderPlayers[playerId] = {
      snake: smoothMe,
      boost: meBaseBoost,
      color: players[playerId].color || "white"
    };
  }

  /* ===== OTHERS ===== */
  const renderTime = timeMs - interpOthers;
  for(const id in players){
    if(id === playerId) continue;
    const sp = sampleInterpSnake(id, renderTime);
    if(!sp) continue;

    const n = sp.snake?.length || 0;
    const tau = Math.min(180, 110 + n * 0.10);
    const alpha = 1 - Math.exp(-dtFrame / tau);

    const smooth = smoothSnake(id, sp.snake, alpha);
    renderPlayers[id] = { snake: smooth, boost: sp.boost, color: sp.color };
  }

  const meRender = renderPlayers[playerId]?.snake || null;
  const boostActive = !!renderPlayers[playerId]?.boost;

  hud.textContent =
`–†–µ–∂–∏–º: ${useTouch ? "–º–æ–± (–¥–∂–æ–π—Å—Ç–∏–∫)" : (useMouse ? "–º—ã—à—å" : "–∫–ª–∞–≤–∞ (A/D —Ä—É–ª–∏—Ç, W –±—ã—Å—Ç—Ä–µ–µ, S —Ç–æ—á–Ω–µ–µ)")} | –ò–≥—Ä–æ–∫–æ–≤: ${Object.keys(players).length} | FPS: ${fps}
Cap: ${Math.round(capHz)} | RTT‚âà${Math.round(rtt)}ms | –£—Å–∫–æ—Ä–µ–Ω–∏–µ: ${boostActive ? "–≤–∫–ª" : "–≤—ã–∫–ª"} | M/–¨: —Ä–µ–∂–∏–º (–ü–ö)`;

  updateCamera(meRender);

  // —Å–µ—Ç–∫–∞
  ctx.strokeStyle="rgba(255,255,255,0.05)";
  const gx0 = -((cameraX % GRID_STEP + GRID_STEP) % GRID_STEP);
  const gy0 = -((cameraY % GRID_STEP + GRID_STEP) % GRID_STEP);
  ctx.beginPath();
  for(let x=gx0; x<VIEW_W; x+=GRID_STEP){ ctx.moveTo(x,0); ctx.lineTo(x,VIEW_H); }
  for(let y=gy0; y<VIEW_H; y+=GRID_STEP){ ctx.moveTo(0,y); ctx.lineTo(VIEW_W,y); }
  ctx.stroke();

  // –µ–¥–∞
  let corpseGlowBudget = lowDetail ? 0 : 120;
  const foodStep = lowDetail ? 2 : 1;
  for(let i=0;i<foods.length;i+=foodStep){
    const f = foods[i];
    const mult = (typeof f.size === "number") ? f.size : 1;
    const baseR0 = (SEGMENT/4) * mult * Math.sqrt(SNAKE_SCALE);

    const x = f.x - cameraX + SEGMENT/2;
    const y = f.y - cameraY + SEGMENT/2;

    const isCorpse = (f.kind === "corpse");
    let alphaMul = 1.0;
    let scaleMul = 1.0;

    if(isCorpse){
      const key = foodKey(f);
      const born = foodBirth.get(key);
      if(typeof born === "number"){
        const t = (timeMs - born) / FOOD_POP_MS;
        const k = easeOutCubic(t);
        alphaMul = 0.10 + 0.90 * k;
        scaleMul = 0.72 + 0.28 * k;
      }
    }

    const baseR = baseR0 * scaleMul;

    ctx.save();
    if(isCorpse){
      ctx.globalAlpha = alphaMul;
      if(corpseGlowBudget > 0){
        corpseGlowBudget--;
        ctx.shadowColor = f.color || "white";
        ctx.shadowBlur = 18 * scaleMul;
      } else {
        ctx.shadowBlur = 0;
      }
    }

    ctx.fillStyle = f.color || (isCorpse ? "white" : "lime");
    ctx.beginPath();
    ctx.arc(x, y, baseR, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // –∑–º–µ–π–∫–∏
  for(const id in renderPlayers){
    const rp = renderPlayers[id];
    drawSnakeRibbon(rp.snake, rp.color, rp.boost, id === playerId, timeMs);
  }

  // –≥—Ä–∞–Ω–∏—Ü—ã –º–∏—Ä–∞
  ctx.strokeStyle="red";
  ctx.lineWidth=4;
  ctx.strokeRect(-cameraX, -cameraY, WORLD_W, WORLD_H);
}

/* =========================
   START / WS
========================= */
function resetMePrediction(){
  meBaseSnake = null;
  meBaseHead = null;
  mePredHead = null;
  meLastPredTs = null;
  meBaseBoost = false;
  predDirUnit = {x:1, y:0};
  initHeadingFromVector(wantDirUnit);
}

function blendSnake(prev, next, k){
  if(!next || !next.length) return next;
  if(!prev || !prev.length) return next.map(p => ({x:p.x, y:p.y}));
  const n = Math.max(prev.length, next.length);
  const out = new Array(n);
  for(let i=0;i<n;i++){
    const a = prev[i] || prev[prev.length-1];
    const b = next[i] || next[next.length-1];
    out[i] = { x: a.x + (b.x - a.x)*k, y: a.y + (b.y - a.y)*k };
  }
  return out;
}

function startGame(){
  dead = false;

  // –°–ö–ï–ô–õ: —Ç–æ–ª—å–∫–æ –¥–ª—è –º–æ–±–∏–ª–∫–∏ —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º
  SNAKE_SCALE = isTouchDevice ? MOBILE_SNAKE_SCALE : DESKTOP_SNAKE_SCALE;

  dir = {x:1,y:0};
  wantDirUnit = {x:1,y:0};
  initHeadingFromVector(wantDirUnit);

  players = {};
  foods = [];
  keysDown.clear();
  serverBoosting = false;

  lastSent = 0;
  lastDirSent = {x:1,y:0};

  lastAxisX = 1;
  lastAxisY = -1;

  cameraX = 0; cameraY = 0;
  for(const id in snapshots) delete snapshots[id];
  for(const id in renderCache) delete renderCache[id];
  foodBirth.clear();

  menu.style.display="none";
  canvas.style.display="block";
  hud.style.display="block";

  useTouch = !!isTouchDevice;
  if(useTouch){
    useMouse = false;
    touchUI.style.display = "block";
    touchUI.setAttribute("aria-hidden","false");
  } else {
    touchUI.style.display = "none";
    touchUI.setAttribute("aria-hidden","true");
  }

  fitCanvas();
  canvas.focus();

  playerId="player"+Math.floor(Math.random()*9999);
  ws=new WebSocket(wsUrl(`/ws/${ROOM_ID}/${playerId}`));

  ws.onopen = () => {
    startRttPing();
    startInputHeartbeat();
  };

  ws.onmessage = (e) => {
    const data = JSON.parse(e.data);

    if (data.type === "pong") {
      const now = performance.now();
      const sample = Math.max(0, now - (data.t || now));
      rtt = rtt*0.8 + sample*0.2;
      return;
    }

    if (data.type === "death") {
      dead = true;
      sendBoost(false);
      resetMePrediction();
      return;
    }

    if (data.players) players = data.players;

    if (Array.isArray(data.foods)) {
      foods = data.foods;
      markFoodBirths(foods, performance.now());
    }

    for (const id in players) pushSnapshot(id, players[id]);

    const me = players[playerId];
    if(me && me.snake && me.snake.length){
      const fresh = me.snake.map(p => ({x:p.x, y:p.y}));
      meBaseSnake = blendSnake(meBaseSnake, fresh, 0.35);

      meBaseHead = {x: meBaseSnake[0].x, y: meBaseSnake[0].y};
      meBaseBoost = !!me.boost;

      if(!mePredHead){
        mePredHead = {x: meBaseHead.x, y: meBaseHead.y};
        predDirUnit = {x: wantDirUnit.x, y: wantDirUnit.y};
        initHeadingFromVector(wantDirUnit);
      } else {
        const k = 0.35;
        mePredHead.x = mePredHead.x + (meBaseHead.x - mePredHead.x) * k;
        mePredHead.y = mePredHead.y + (meBaseHead.y - mePredHead.y) * k;
      }
    }
  };

  ws.onclose=()=>{
    if(rttTimer){ clearInterval(rttTimer); rttTimer = null; }
    if(inputTimer){ clearInterval(inputTimer); inputTimer = null; }
    sendBoost(false);

    touchUI.style.display = "none";
    touchUI.setAttribute("aria-hidden","true");

    setTimeout(()=>{
      canvas.style.display="none";
      hud.style.display="none";
      menu.style.display="flex";
    }, 150);
  };
}

/* =========================
   INPUT (–ü–ö)
========================= */
canvas.addEventListener("mousemove", e=>{
  if(useTouch) return;
  if(!useMouse) return;
  if(dead) return;

  const head = getMyHead();
  if(!head) return;

  const mx = e.clientX + cameraX - head.x;
  const my = e.clientY + cameraY - head.y;
  if(Math.abs(mx) + Math.abs(my) < 0.001) return;

  mouseTargetHeading = Math.atan2(my, mx);
});

document.addEventListener("keydown", e=>{
  if(useTouch) return;
  const k = (e.key || "").toLowerCase();

  // M –∏–ª–∏ –¨
  if(k === "m" || k === "—å"){
    useMouse = !useMouse;
    keysDown.clear();
    mouseTargetHeading = heading;
    e.preventDefault?.();
  }
});

function updateAxisOnPress(k){
  if(k === "a") lastAxisX = -1;
  if(k === "d") lastAxisX =  1;
  if(k === "w") lastAxisY = -1;
  if(k === "s") lastAxisY =  1;
}

document.addEventListener("keydown", e=>{
  if(useTouch) return;
  if(dead) return;

  const k = normKey(e.key);

  // —É—Å–∫–æ—Ä–µ–Ω–∏–µ –Ω–∞ –ø—Ä–æ–±–µ–ª
  if(k === " " || k === "space" || e.code === "Space"){
    sendBoost(true);
    e.preventDefault?.();
    return;
  }

  if(k === "w" || k === "a" || k === "s" || k === "d"){
    if(!keysDown.has(k)){
      keysDown.add(k);
      updateAxisOnPress(k);
    }
    e.preventDefault?.();
  }
});

document.addEventListener("keyup", e=>{
  if(useTouch) return;
  const k = normKey(e.key);

  if(k === " " || k === "space" || e.code === "Space"){
    sendBoost(false);
    e.preventDefault?.();
    return;
  }

  if(k === "w" || k === "a" || k === "s" || k === "d"){
    keysDown.delete(k);
    e.preventDefault?.();
  }
});

window.addEventListener("blur", () => sendBoost(false));
document.addEventListener("visibilitychange", () => { if(document.hidden) sendBoost(false); });

/* =========================
   INPUT (MOBILE): JOYSTICK + BOOST
========================= */
const joy = { active:false, pid:null, radius:48, x:0, y:0 };

function setKnob(dx, dy){
  joyKnob.style.transform = `translate(${dx}px, ${dy}px)`;
}

function joyReset(){
  joy.active = false;
  joy.pid = null;
  joy.x = joy.y = 0;
  setKnob(0,0);
  touchTargetHeading = heading;
}

function joyUpdateFromPointer(clientX, clientY){
  const rect = joyWrap.getBoundingClientRect();
  const cx = rect.left + rect.width/2;
  const cy = rect.top + rect.height/2;

  const dx0 = clientX - cx;
  const dy0 = clientY - cy;

  const r = joy.radius;
  const len = Math.hypot(dx0, dy0);

  let dx = dx0, dy = dy0;
  if(len > r){
    const k = r / len;
    dx *= k; dy *= k;
  }

  joy.x = dx;
  joy.y = dy;

  setKnob(dx, dy);

  if(Math.abs(dx) + Math.abs(dy) < 2){
    touchTargetHeading = heading;
    return;
  }

  touchTargetHeading = Math.atan2(dy, dx);
}

joyWrap.addEventListener("pointerdown", (e)=>{
  if(!useTouch) return;
  if(dead) return;

  joy.active = true;
  joy.pid = e.pointerId;
  joyWrap.setPointerCapture(e.pointerId);
  joyUpdateFromPointer(e.clientX, e.clientY);
  e.preventDefault();
});

joyWrap.addEventListener("pointermove", (e)=>{
  if(!useTouch || !joy.active) return;
  if(e.pointerId !== joy.pid) return;
  joyUpdateFromPointer(e.clientX, e.clientY);
  e.preventDefault();
});

function joyEnd(e){
  if(!useTouch || !joy.active) return;
  if(e && e.pointerId != null && e.pointerId !== joy.pid) return;
  joyReset();
  e?.preventDefault?.();
}
joyWrap.addEventListener("pointerup", joyEnd);
joyWrap.addEventListener("pointercancel", joyEnd);
joyWrap.addEventListener("lostpointercapture", joyEnd);

/* boost button */
function bindHoldButton(btn, onDown, onUp){
  btn.addEventListener("pointerdown", (e)=>{ if(!useTouch) return; onDown(); btn.setPointerCapture(e.pointerId); e.preventDefault(); });
  btn.addEventListener("pointerup",   (e)=>{ if(!useTouch) return; onUp();   e.preventDefault(); });
  btn.addEventListener("pointercancel",(e)=>{ if(!useTouch) return; onUp();  e.preventDefault(); });
  btn.addEventListener("lostpointercapture",(e)=>{ if(!useTouch) return; onUp(); e.preventDefault(); });
}
bindHoldButton(boostBtn, ()=>sendBoost(true), ()=>sendBoost(false));

/* =========================
   START
========================= */
playBtn.addEventListener("click", startGame);
fitCanvas();
requestAnimationFrame(draw);
</script>
</body>
</html>
