<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Snake Smooth Multiplayer</title>
  <style>
    html,body{
      margin:0;padding:0;
      overflow:hidden;
      font-family:Arial,sans-serif;
      background: linear-gradient(135deg, #1a1a1a 0%, #111 100%);
      color:white;
      height:100%;
      overscroll-behavior: none;
      -webkit-overflow-scrolling: auto;
      touch-action: none;
    }
    body{ position:fixed; inset:0; }
    canvas{ display:block; outline:none; touch-action:none; }
    #menu{
      position:fixed;inset:0;
      display:flex;align-items:center;justify-content:center;flex-direction:column;
      background: rgba(0,0,0,0.82);
      gap:14px;text-align:center;padding:24px;box-sizing:border-box;
      z-index:30;
      touch-action:none;
    }
    button{font-size:24px;padding:15px 40px;cursor:pointer;border:none;background:lime;color:black;border-radius:10px;}
    button:hover{background:#7CFF7C;}
    .hud{
      position:fixed;left:12px;top:10px;z-index:25;
      font-size:14px;opacity:.85;user-select:none;pointer-events:none;
      text-shadow:0 1px 2px rgba(0,0,0,.6);
      line-height:1.35;white-space:pre;
    }

    #touchUI{
      position:fixed; inset:0; z-index:20;
      display:none;
      pointer-events:none;
      touch-action:none;
    }

    #joyWrap{
      position:absolute;
      pointer-events:auto; touch-action:none;
      left: max(39px, env(safe-area-inset-left));
      bottom: calc(26px + env(safe-area-inset-bottom));
      width:150px; height:150px;
      -webkit-user-select:none; user-select:none;
      -webkit-tap-highlight-color:transparent;
    }
    #joyBase{
      width:100%; height:100%;
      border-radius:999px;
      background:rgba(255,255,255,0.10);
      border:1px solid rgba(255,255,255,0.18);
      backdrop-filter: blur(4px);
      position:relative;
    }
    #joyKnob{
      position:absolute; left:50%; top:50%;
      width:54px; height:54px;
      margin-left:-27px; margin-top:-27px;
      border-radius:999px;
      background:rgba(255,255,255,0.22);
      border:1px solid rgba(255,255,255,0.25);
      box-shadow:0 8px 18px rgba(0,0,0,.35);
      transform:translate(0,0);
      will-change:transform;
    }

    #btnWrap{
      position:absolute;
      pointer-events:auto; touch-action:none;
      right: max(50px, env(safe-area-inset-right));
      bottom: calc(74px + env(safe-area-inset-bottom));
      display:flex; flex-direction:column; gap:12px;
      -webkit-user-select:none; user-select:none;
      -webkit-tap-highlight-color:transparent;
    }

    #boostBtn,.boostBtn{
      -webkit-user-select:none; user-select:none;
      -webkit-touch-callout:none;
      -webkit-tap-highlight-color:transparent;
      outline:none; -webkit-appearance:none; appearance:none;
      caret-color:transparent;
      touch-action:none;
    }
    #boostBtn:focus,#boostBtn:focus-visible{ outline:none; }

    .boostBtn{
      width:86px; height:86px; border-radius:999px;
      display:flex; align-items:center; justify-content:center;
      font-size:38px; font-weight:700;
      background: rgba(255, 208, 64, 0.34);
      border: 1px solid rgba(255, 225, 120, 0.34);
      backdrop-filter: blur(4px);
      color:#111;
      box-shadow: 0 10px 22px rgba(0,0,0,.30);
      -webkit-tap-highlight-color: transparent;
    }
    .boostBtn .icon{ display:block; line-height:1; pointer-events:none; user-select:none; }
    .boostBtn:active{
      transform: scale(0.96);
      box-shadow: 0 6px 14px rgba(0,0,0,.28);
    }

    @media (pointer:coarse){
      .hud{top:8px;left:10px;font-size:12px;opacity:.78;}
    }
  </style>
</head>
<body>
  <div id="menu">
    <h1>üêç Snake</h1>
    <button id="playBtn">–ò–≥—Ä–∞—Ç—å</button>
  </div>

  <div id="hud" class="hud" style="display:none"></div>

  <!-- –ù–∞ —Å—Ç–∞—Ä—Ç–µ –ø—Ä—è—á–µ–º canvas, —á—Ç–æ–±—ã –ø–æ–¥ –º–µ–Ω—é –Ω–µ –±—ã–ª–æ –∫—Ä–∞—Å–Ω–æ–π —Ä–∞–º–∫–∏ –∏ –ø—Ä–æ—á–µ–≥–æ -->
  <canvas id="game" tabindex="0" style="display:none"></canvas>

  <div id="touchUI" aria-hidden="true">
    <div id="joyWrap">
      <div id="joyBase"><div id="joyKnob"></div></div>
    </div>
    <div id="btnWrap">
      <button id="boostBtn" class="boostBtn" aria-label="–£—Å–∫–æ—Ä–µ–Ω–∏–µ">
        <span class="icon" aria-hidden="true">‚ö°</span>
      </button>
    </div>
  </div>

<script>
/* hard stop: no page pull/zoom */
document.addEventListener("touchmove", (e)=>{ e.preventDefault(); }, {passive:false});
document.addEventListener("gesturestart", (e)=>{ e.preventDefault(); }, {passive:false});
document.addEventListener("gesturechange",(e)=>{ e.preventDefault(); }, {passive:false});
document.addEventListener("gestureend",   (e)=>{ e.preventDefault(); }, {passive:false});
window.addEventListener("scroll", ()=>window.scrollTo(0,0), {passive:true});

const WORLD_W = 3000, WORLD_H = 3000;
const SEGMENT = 30;
const ROOM_ID = "room1";

const CLIENT_SPEED = 4;
const SEG_DIST = SEGMENT * 0.85;

let ws=null, playerId=null, foods=[], cameraX=0, cameraY=0;
let dir = {x:1, y:0}, dead=false;

let deathAtMs = null;
let lastMeHead = null;
let lastMeHeadTs = null;
let lastMeVel = { vx: 0, vy: 0 };
const DEATH_FADE_MS = 650;
const DEATH_HOLD_MS = 520;
let deathMenuTimer = null;

let useMouse = false;
let useTouch = false;

let serverBoosting = false;
const keysDown = new Set();
let lastAxisX = 1;
let lastAxisY = -1;

const menu=document.getElementById("menu"),
      playBtn=document.getElementById("playBtn"),
      canvas=document.getElementById("game"),
      hud=document.getElementById("hud"),
      ctx=canvas.getContext("2d");

const touchUI = document.getElementById("touchUI");
const joyWrap = document.getElementById("joyWrap");
const joyKnob = document.getElementById("joyKnob");
const boostBtn = document.getElementById("boostBtn");

const isTouchDevice =
  (window.matchMedia && window.matchMedia("(pointer:coarse)").matches) ||
  ("ontouchstart" in window) ||
  (navigator.maxTouchPoints > 0);

function wsUrl(path){
  return `wss://${location.host}${path}`;
}

function clamp01(v){ return Math.max(-1, Math.min(1, v)); }
function lerp(a,b,t){ return a + (b-a)*t; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function smoothstep01(t){
  t = clamp(t, 0, 1);
  return t * t * (3 - 2 * t);
}
function normAngle(a){
  while(a > Math.PI) a -= Math.PI*2;
  while(a < -Math.PI) a += Math.PI*2;
  return a;
}

/* ===== VIEW / SNAKE SIZE ===== */
const DESKTOP_SNAKE_SCALE = 1.35;
const MOBILE_VIEW_ZOOM    = 0.82;
const MOBILE_SNAKE_SCALE  = 1.29;

let SNAKE_SCALE = DESKTOP_SNAKE_SCALE;
let GRID_STEP = Math.round(SEGMENT * 2.4);
let VIEW_ZOOM = 1;

/* FPS */
let lastFpsTs = performance.now();
let frames = 0;
let lowDetail = false;
let fps = 60;

function updateFpsOnRenderedFrame(timeMs){
  frames++;
  const dt = timeMs - lastFpsTs;
  if(dt >= 500){
    fps = Math.round((frames * 1000) / dt);
    frames = 0;
    lastFpsTs = timeMs;
    lowDetail = fps < 45;
    GRID_STEP = Math.round(SEGMENT * (lowDetail ? 3.2 : 2.4));
  }
}

/* RTT */
let rtt = 60;
let rttTimer = null;
function startRttPing(){
  if(rttTimer) clearInterval(rttTimer);
  rttTimer = setInterval(()=>{
    if(!ws || ws.readyState !== 1) return;
    ws.send(JSON.stringify({type:"ping", t: performance.now()}));
  }, 800);
}

/* RAF cap */
const TARGET_CAP = 75;
const rafMeter = { lastTs: null, samples: [], maxSamples: 90, hz: 60 };
function updateRafHz(ts){
  if(rafMeter.lastTs == null){ rafMeter.lastTs = ts; return; }
  const dt = ts - rafMeter.lastTs;
  rafMeter.lastTs = ts;
  if(dt <= 0) return;
  const instHz = 1000 / dt;
  if(instHz < 10 || instHz > 400) return;
  rafMeter.samples.push(instHz);
  if(rafMeter.samples.length > rafMeter.maxSamples) rafMeter.samples.shift();
  const a = rafMeter.samples.slice().sort((x,y)=>x-y);
  const mid = a.length >> 1;
  const med = a.length ? (a.length % 2 ? a[mid] : (a[mid-1]+a[mid])/2) : 60;
  const snap = (v) => {
    const presets = [50,60,75,90,100,120,144,165,180,240];
    let best=v, bestD=1e9;
    for(const p of presets){
      const d = Math.abs(v-p);
      if(d<bestD){ bestD=d; best=p; }
    }
    return (bestD <= 3.0) ? best : v;
  };
  rafMeter.hz = snap(med);
}
let capHz = 60;
function getCapHz(){ return Math.min(rafMeter.hz || 60, TARGET_CAP); }

/* CANVAS SIZE */
let VIEW_W = innerWidth, VIEW_H = innerHeight;

function fitCanvas(){
  const vv = window.visualViewport;
  const w = vv ? Math.round(vv.width)  : innerWidth;
  const h = vv ? Math.round(vv.height) : innerHeight;
  VIEW_W = w; VIEW_H = h;
  if(isTouchDevice){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.style.width = w + "px";
    canvas.style.height = h + "px";
    canvas.width  = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.imageSmoothingEnabled = true;
  } else {
    canvas.width = w;
    canvas.height = h;
    ctx.setTransform(1,0,0,1,0,0);
  }
}
window.addEventListener("resize", fitCanvas);
window.visualViewport?.addEventListener("resize", fitCanvas);
window.visualViewport?.addEventListener("scroll", fitCanvas);

/* RENDER HELPERS */
function bodyWidth(){ return SEGMENT * 0.95 * SNAKE_SCALE; }
function headRadius(){ return bodyWidth() * 0.50; }
function eyeWhiteR(){ return headRadius() * 0.38; }
function eyePupilR(){ return eyeWhiteR() * 0.45; }
function pupilShift(){ return eyeWhiteR() * 0.35; }

/* CAMERA */
let camHX = null, camHY = null;
const CAM_SMOOTH = 0.18;
function updateCamera(renderMeSnake){
  if(!renderMeSnake || renderMeSnake.length === 0) return;
  const h = renderMeSnake[0];
  if(camHX === null){ camHX = h.x; camHY = h.y; }
  camHX = camHX + (h.x - camHX) * CAM_SMOOTH;
  camHY = camHY + (h.y - camHY) * CAM_SMOOTH;
  cameraX = camHX - (VIEW_W / (2 * VIEW_ZOOM));
  cameraY = camHY - (VIEW_H / (2 * VIEW_ZOOM));
}
function sx(wx){ return (wx - cameraX) * VIEW_ZOOM + SEGMENT/2; }
function sy(wy){ return (wy - cameraY) * VIEW_ZOOM + SEGMENT/2; }

/* ===== Background (slither-like hex) ===== */
let bgPattern = null;
let bgTileSize = 220;

function buildHexTile(size){
  const c = document.createElement("canvas");
  c.width = c.height = size;
  const g = c.getContext("2d");

  const grad = g.createLinearGradient(0,0,size,size);
  grad.addColorStop(0, "#171b22");
  grad.addColorStop(1, "#0f1218");
  g.fillStyle = grad;
  g.fillRect(0,0,size,size);

  const r = size * 0.22;
  const cx = size * 0.50;
  const cy = size * 0.50;
  const lineA = "rgba(255,255,255,0.055)";
  const lineB = "rgba(0,0,0,0.55)";

  function hexPath(x,y,rad){
    g.beginPath();
    for(let i=0;i<6;i++){
      const a = (Math.PI/3)*i + Math.PI/6;
      const px = x + Math.cos(a)*rad;
      const py = y + Math.sin(a)*rad;
      if(i===0) g.moveTo(px,py); else g.lineTo(px,py);
    }
    g.closePath();
  }

  const offsets = [
    [0,0],[size*0.5,size*0.0],
    [size*0.0,size*0.5],[size*0.5,size*0.5]
  ];

  for(const [ox,oy] of offsets){
    const x = cx + ox - size*0.25;
    const y = cy + oy - size*0.25;

    g.save();
    g.shadowColor = "rgba(0,0,0,0.75)";
    g.shadowBlur = r * 0.55;
    g.shadowOffsetY = r * 0.12;

    const fill = g.createRadialGradient(x - r*0.2, y - r*0.2, r*0.2, x, y, r*1.35);
    fill.addColorStop(0, "rgba(90,110,150,0.20)");
    fill.addColorStop(1, "rgba(0,0,0,0.10)");
    g.fillStyle = fill;

    hexPath(x,y,r);
    g.fill();
    g.restore();

    g.lineWidth = Math.max(1, size * 0.006);

    g.strokeStyle = lineB;
    g.save();
    g.translate(0, 1);
    hexPath(x,y,r);
    g.stroke();
    g.restore();

    g.strokeStyle = lineA;
    hexPath(x,y,r);
    g.stroke();
  }

  return c;
}

function ensureBgPattern(){
  const vv = window.visualViewport;
  const w = vv ? Math.round(vv.width) : innerWidth;
  const want = Math.round((isTouchDevice ? 260 : 220) * (w < 520 ? 1.08 : 1.0));
  if(bgPattern && bgTileSize === want) return;

  bgTileSize = want;
  const tile = buildHexTile(bgTileSize);
  bgPattern = ctx.createPattern(tile, "repeat");
}

function drawBackground(){
  ensureBgPattern();
  ctx.save();
  ctx.fillStyle = bgPattern;
  ctx.fillRect(0,0,VIEW_W,VIEW_H);

  const v = ctx.createRadialGradient(
    VIEW_W*0.5, VIEW_H*0.5, Math.min(VIEW_W,VIEW_H)*0.10,
    VIEW_W*0.5, VIEW_H*0.5, Math.max(VIEW_W,VIEW_H)*0.75
  );
  v.addColorStop(0, "rgba(0,0,0,0)");
  v.addColorStop(1, "rgba(0,0,0,0.55)");
  ctx.fillStyle = v;
  ctx.fillRect(0,0,VIEW_W,VIEW_H);
  ctx.restore();
}

/* EYES */
function drawSnakeEyes(s, look){
  if(!s || s.length < 2) return;
  const h = s[0], n = s[1];
  let fx = h.x - n.x, fy = h.y - n.y;
  const fl = Math.hypot(fx, fy) || 1;
  fx/=fl; fy/=fl;
  const lx = -fy, ly = fx;
  const cx = sx(h.x), cy = sy(h.y);
  const HR  = headRadius() * VIEW_ZOOM;
  const EWR = eyeWhiteR() * VIEW_ZOOM;
  const EPR = eyePupilR() * VIEW_ZOOM;
  const PS  = pupilShift() * VIEW_ZOOM;
  const side = HR * 0.55, fwd = HR * 0.20;
  const ex1 = cx + lx*side + fx*fwd;
  const ey1 = cy + ly*side + fy*fwd;
  const ex2 = cx - lx*side + fx*fwd;
  const ey2 = cy - ly*side + fy*fwd;

  let dx = look?.x ?? fx, dy = look?.y ?? fy;
  const dl = Math.hypot(dx, dy) || 1; dx/=dl; dy/=dl;
  const lookF = clamp01(dx*fx + dy*fy);
  const lookL = clamp01(dx*lx + dy*ly);
  const pxShiftX = fx*(lookF*PS) + lx*(lookL*PS);
  const pxShiftY = fy*(lookF*PS) + ly*(lookL*PS);

  ctx.save();
  ctx.fillStyle = "white";
  ctx.beginPath(); ctx.arc(ex1, ey1, EWR, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(ex2, ey2, EWR, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = "black";
  ctx.beginPath(); ctx.arc(ex1 + pxShiftX, ey1 + pxShiftY, EPR, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(ex2 + pxShiftX, ey2 + pxShiftY, EPR, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

function decimate(points, step){
  if(step <= 1) return points;
  const out = [];
  for(let i=0;i<points.length;i+=step) out.push(points[i]);
  if(points.length && out[out.length-1] !== points[points.length-1]) out.push(points[points.length-1]);
  return out;
}

function drawSnakeRibbon(renderSnake, color, boost, isMe, timeMs){
  const base = renderSnake || [];
  if(base.length < 2) return;

  let didFade = false;
  let a = 1.0;
  if(isMe && dead && deathAtMs != null){
    const k = smoothstep01((timeMs - deathAtMs) / 160);
    a = 1 - k;
    ctx.save();
    ctx.globalAlpha *= a;
    didFade = true;
  }

  let s;
  if(isMe){
    const n = base.length|0;
    const step = (n > 360) ? 3 : (n > 220 ? 2 : 1);
    s = (step === 1) ? base : decimate(base, step);
  } else {
    s = decimate(base, lowDetail ? 3 : 2);
  }

  const shrink = (isMe && dead && deathAtMs != null) ? (0.25 + 0.75*a) : 1.0;

  const BW = bodyWidth() * VIEW_ZOOM * shrink;
  const HR = headRadius() * VIEW_ZOOM * shrink;

  if(boost){
    const pulse1 = 0.5 + 0.5*Math.sin(timeMs * 0.022);
    const pulse2 = 0.5 + 0.5*Math.sin(timeMs * 0.017 + 1.2);
    const glowAlpha = lowDetail ? 0.10 : (0.16 + 0.10*pulse1);
    const glowW = BW * ((isMe ? 2.10 : 1.95) + 0.45*pulse2);

    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.strokeStyle = `rgba(255,255,255,${glowAlpha})`;
    ctx.lineWidth = glowW;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.beginPath();
    ctx.moveTo(sx(s[0].x), sy(s[0].y));
    for(let i=1;i<s.length;i++) ctx.lineTo(sx(s[i].x), sy(s[i].y));
    ctx.stroke();
    ctx.restore();
  }

  ctx.strokeStyle = color || "white";
  ctx.lineWidth = BW;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  ctx.beginPath();
  ctx.moveTo(sx(s[0].x), sy(s[0].y));
  for(let i=1;i<s.length;i++) ctx.lineTo(sx(s[i].x), sy(s[i].y));
  ctx.stroke();

  const head = s[0];
  ctx.fillStyle = color || "white";
  ctx.beginPath();
  ctx.arc(sx(head.x), sy(head.y), HR, 0, Math.PI*2);
  ctx.fill();

  let look = null;
  if(isMe){
    look = { x: dir?.x ?? 1, y: dir?.y ?? 0 };
  } else {
    const hh = s[0], nn = s[1];
    look = { x: hh.x - nn.x, y: hh.y - nn.y };
  }
  drawSnakeEyes(s, look);

  if(didFade) ctx.restore();
}

/* ====== remote players ====== */
const remote = {};
const REMOTE_PATH_MAX = 1400;

function buildSnakeFromPath(path, lengthUnits){
  const lu = Math.max(1, +lengthUnits || 1);
  const tailDist = Math.max(0, (lu - 1) * SEG_DIST);
  const nPoints = Math.max(1, Math.floor(tailDist / SEG_DIST) + 2);

  if(!path || path.length === 0) return [{x:0,y:0}];

  const out = [];
  out.push({x: path[0].x, y: path[0].y});
  if(nPoints === 1) return out;

  let acc = 0;
  let nextMark = SEG_DIST;

  for(let i=0;i<path.length-1 && out.length < nPoints;i++){
    const a = path[i];
    const b = path[i+1];
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const segLen = Math.hypot(dx, dy);
    if(segLen < 1e-6) continue;

    while(nextMark <= acc + segLen + 1e-6){
      const t = (nextMark - acc) / segLen;
      out.push({ x: a.x + dx*t, y: a.y + dy*t });
      if(nextMark >= tailDist - 1e-6) return out;
      nextMark += SEG_DIST;
      if(nextMark > tailDist) nextMark = tailDist;
    }

    acc += segLen;
  }

  const last = out[out.length-1] || {x:0,y:0};
  while(out.length < nPoints) out.push({x:last.x, y:last.y});
  return out;
}

function snakePointsFromFlatBody(bodyFlat){
  const out = [];
  if(!Array.isArray(bodyFlat)) return out;
  for(let i=0;i<bodyFlat.length;i+=2){
    out.push({ x: +bodyFlat[i], y: +bodyFlat[i+1] });
  }
  return out;
}

function padToLen(snake, n){
  if(!snake) return snake;
  const m = snake.length|0;
  if(m >= n) return snake;
  const out = snake.slice();
  const last = out.length ? out[out.length-1] : {x:0,y:0};
  while(out.length < n) out.push({x:last.x, y:last.y});
  return out;
}

/* render-in-the-past interpolation */
const INTERP_DELAY_MS = isTouchDevice ? 200 : 160;
const SNAP_MAX = 12;

function snakeToFlatF32(snake){
  const n = snake.length|0;
  const out = new Float32Array(n * 2);
  for(let i=0;i<n;i++){
    out[i*2]   = snake[i].x;
    out[i*2+1] = snake[i].y;
  }
  return out;
}
function padFlatToLen(flat, wantFloats){
  if(!flat) return flat;
  const m = flat.length|0;
  if(m >= wantFloats) return flat;
  const out = new Float32Array(wantFloats);
  out.set(flat);
  const lx = m >= 2 ? flat[m-2] : 0;
  const ly = m >= 2 ? flat[m-1] : 0;
  for(let i=m;i<wantFloats;i+=2){
    out[i] = lx; out[i+1] = ly;
  }
  return out;
}
function flatF32ToPoints(flat){
  const n = (flat.length/2)|0;
  const out = new Array(n);
  for(let i=0;i<n;i++){
    out[i] = { x: flat[i*2], y: flat[i*2+1] };
  }
  return out;
}

function pushSnap(r, snake, timeMs){
  if(!snake || snake.length < 2) return;
  if(!r.snaps) r.snaps = [];
  r.snaps.push({
    t: timeMs,
    flat: snakeToFlatF32(snake),
    boost: !!r.boost,
    color: r.color || "white",
  });
  if(r.snaps.length > SNAP_MAX) r.snaps.shift();
}

function interpSnakeFromSnaps(snaps, renderTime){
  if(!snaps || snaps.length === 0) return null;
  if(snaps.length === 1) return flatF32ToPoints(snaps[0].flat);

  if(renderTime <= snaps[0].t) return flatF32ToPoints(snaps[0].flat);
  const last = snaps[snaps.length - 1];
  if(renderTime >= last.t) return flatF32ToPoints(last.flat);

  let i = snaps.length - 2;
  while(i >= 0 && snaps[i].t > renderTime) i--;
  i = Math.max(0, i);

  const a = snaps[i];
  const b = snaps[i + 1] || a;
  const span = Math.max(1, b.t - a.t);
  const k = Math.max(0, Math.min(1, (renderTime - a.t) / span));

  let fa = a.flat, fb = b.flat;
  if(!fa || !fb) return null;

  const n = Math.max(fa.length, fb.length);
  fa = padFlatToLen(fa, n);
  fb = padFlatToLen(fb, n);

  const out = new Float32Array(n);
  for(let j=0;j<n;j++) out[j] = lerp(fa[j], fb[j], k);
  return flatF32ToPoints(out);
}

/* smoothing */
const renderCache = {};
function smoothSnake(id, targetSnake, alpha){
  if(!targetSnake || targetSnake.length === 0) return targetSnake;

  let prev = renderCache[id];

  if(!prev || prev.length === 0){
    renderCache[id] = targetSnake.map(p => ({x:p.x, y:p.y}));
    return renderCache[id];
  }

  const n = Math.max(prev.length, targetSnake.length);
  prev = padToLen(prev, n);
  const tgt = padToLen(targetSnake, n);

  const out = new Array(n);
  for(let i=0;i<n;i++){
    const tp = tgt[i];
    const pp = prev[i] || tp;
    out[i] = { x: lerp(pp.x, tp.x, alpha), y: lerp(pp.y, tp.y, alpha) };
  }
  renderCache[id] = out;
  return out;
}

/* INPUT + STEERING */
function normKey(k){
  k = (k || "").toLowerCase();
  if(k === "—Ü") return "w";
  if(k === "—Ñ") return "a";
  if(k === "—ã") return "s";
  if(k === "–≤") return "d";
  return k;
}

let lastSent = 0;
let lastDirSent = {x:1, y:0};

const SEND_EPS2 = 0.00025;
const SEND_MIN_MS = 20;
const SEND_IDLE_MS = 90;

function sendDirection(nx, ny){
  if(!ws) return;
  if(dead) return;
  if(ws.readyState !== 1) return;

  const now = performance.now();
  const dx = nx - lastDirSent.x;
  const dy = ny - lastDirSent.y;
  const changed = (dx*dx + dy*dy) > SEND_EPS2;

  if(!changed && (now - lastSent) < SEND_IDLE_MS) return;
  if((now - lastSent) < SEND_MIN_MS) return;

  lastSent = now;
  lastDirSent = {x:nx, y:ny};
  ws.send(JSON.stringify({direction: {x: nx, y: ny}}));
}

function getMyHeadWorld(){
  const cached = renderCache[playerId];
  if(cached && cached.length) return cached[0];
  const r = remote[playerId];
  if(r?.head) return r.head;
  return null;
}

/* ===== anti ‚Äútele-eat‚Äù: assist VERY close-range (weaker + shorter) ===== */
const MAGNET_RADIUS = 20;  // –£–º–µ–Ω—å—à–∞–µ–º —Ä–∞–¥–∏—É—Å –º–∞–≥–Ω–∏—Ç–Ω–æ–≥–æ –ø—Ä–∏—Ç—è–∂–µ–Ω–∏—è
const MAGNET_MAX = 0.028;
const MAGNET_WHEN_BOOST = 0.035; // –°–Ω–∏–∂–µ–Ω–∞ —Å–∏–ª–∞ –ø—Ä–∏—Ç—è–∂–µ–Ω–∏—è –ø—Ä–∏ —É—Å–∫–æ—Ä–µ–Ω–∏–∏

function findNearestFoodDir(head){
  if(!head || !foods || !foods.length) return null;

  let bestD2 = MAGNET_RADIUS * MAGNET_RADIUS;
  let best = null;

  for(const f of foods){
    const dx = (f.x - head.x);
    const dy = (f.y - head.y);
    const d2 = dx*dx + dy*dy;
    if(d2 < bestD2){
      bestD2 = d2;
      best = {dx, dy, d2};
    }
  }

  if(!best) return null;

  const d = Math.sqrt(best.d2) || 1;
  const k = (d < MAGNET_RADIUS * 0.7) ? 1 : (1 - (d / MAGNET_RADIUS));
  return { x: best.dx / d, y: best.dy / d, k };
}

function applyMagnetToDir(nx, ny){
  // –ù–∞ –ü–ö —Å –º—ã—à—å—é –º–∞–≥–Ω–∏—Ç –ª—É—á—à–µ –æ—Ç–∫–ª—é—á–∏—Ç—å, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –æ—â—É—â–µ–Ω–∏—è ‚Äú—Å–∞–º–æ –µ—Å—Ç‚Äù
  if(!isTouchDevice && useMouse) return {nx, ny};

  const head = getMyHeadWorld();
  const t = findNearestFoodDir(head);
  if(!t) return {nx, ny};

  const k = smoothstep01(t.k);
  if(k < 0.62) return {nx, ny}; // –≤–∫–ª—é—á–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –æ—á–µ–Ω—å –±–ª–∏–∑–∫–æ

  const boostMul = serverBoosting ? MAGNET_WHEN_BOOST : 1.0;
  const m = MAGNET_MAX * k * boostMul;

  let x = nx * (1 - m) + t.x * m;
  let y = ny * (1 - m) + t.y * m;

  const l = Math.hypot(x, y) || 1;
  x /= l; y /= l;
  return {nx: x, ny: y};
}

function setDirUnit(nx, ny){
  const l = Math.hypot(nx, ny) || 1;
  nx /= l; ny /= l;

  const mm = applyMagnetToDir(nx, ny);
  nx = mm.nx; ny = mm.ny;

  dir = {x: nx*CLIENT_SPEED, y: ny*CLIENT_SPEED};
  sendDirection(nx, ny);
}

let heading = 0;
let angVel = 0;

const TURN_BASE = 10.0;
const TURN_FAST = 15.00;
const TURN_SLOW = 5.0;

const TURN_TAU_MS = 50;
const TURN_STOP_TAU_MS = 105;

const MOUSE_GAIN = 8.4;
const MOUSE_TAU_MS = 25;
const MOUSE_DEADZONE_RAD = 0.005;

const TOUCH_GAIN = 5.0;
const TOUCH_TAU_MS = 15;

let mouseTargetHeading = null;
let touchTargetHeading = null;

function initHeadingFromVector(v){
  heading = Math.atan2(v.y, v.x);
  angVel = 0;
  mouseTargetHeading = heading;
  touchTargetHeading = heading;
}

function applySteeringKeyboard(dtMs){
  const left  = keysDown.has("a");
  const right = keysDown.has("d");
  const fast  = keysDown.has("w");
  const slow  = keysDown.has("s");

  let turn = 0;
  if(left && !right) turn = -1;
  else if(right && !left) turn = 1;
  else if(left && right) turn = lastAxisX;

  let turnRate = TURN_BASE;
  if(fast && !slow) turnRate = TURN_FAST;
  if(slow && !fast) turnRate = TURN_SLOW;

  const targetAngVel = turn * turnRate;
  const tau = (turn !== 0) ? TURN_TAU_MS : TURN_STOP_TAU_MS;
  const k = 1 - Math.exp(-dtMs / tau);
  angVel = angVel + (targetAngVel - angVel) * k;

  heading += angVel * (dtMs / 1000);
  setDirUnit(Math.cos(heading), Math.sin(heading));
}

function applySteeringPointer(dtMs){
  const target = useTouch ? touchTargetHeading : mouseTargetHeading;
  if(target == null) return;

  const err = normAngle(target - heading);
  const maxVel = TURN_FAST;

  const gain = useTouch ? TOUCH_GAIN : MOUSE_GAIN;
  const tau  = useTouch ? TOUCH_TAU_MS : MOUSE_TAU_MS;

  let targetAngVel = 0;
  if(Math.abs(err) > MOUSE_DEADZONE_RAD){
    targetAngVel = clamp(err * gain, -maxVel, +maxVel);
  }

  const k = 1 - Math.exp(-dtMs / tau);
  angVel = angVel + (targetAngVel - angVel) * k;
  heading += angVel * (dtMs / 1000);
  setDirUnit(Math.cos(heading), Math.sin(heading));
}

function applySteering(dtMs){
  if(!ws || ws.readyState !== 1) return;
  if(dead) return;
  if(useTouch) applySteeringPointer(dtMs);
  else if(useMouse) applySteeringPointer(dtMs);
  else applySteeringKeyboard(dtMs);
}

let inputTimer = null;
let lastInputTs = null;
function startInputHeartbeat(){
  if(inputTimer) clearInterval(inputTimer);
  lastInputTs = performance.now();
  inputTimer = setInterval(()=>{
    if(!ws || ws.readyState !== 1) return;
    if(dead) return;
    const now = performance.now();
    let dt = now - lastInputTs;
    lastInputTs = now;
    if(dt < 1) dt = 1;
    if(dt > 40) dt = 40;
    applySteering(dt);
  }, 16);
}

function sendBoost(state){
  if(!ws) return;
  if(ws.readyState !== 1) return;
  if(state === serverBoosting) return;
  serverBoosting = state;
  ws.send(JSON.stringify({boost: state}));
}

/* FOOD pop + visual smoothing */
const foodBirth = new Map();
const foodVis = new Map();

function expLerpFactor(dtMs, tauMs){
  return 1 - Math.exp(-dtMs / Math.max(1, tauMs));
}

function getFoodVis(key, tx, ty){
  let v = foodVis.get(key);
  if(!v){
    v = { x: tx, y: ty };
    foodVis.set(key, v);
  }
  return v;
}

function cleanupFoodVis(currentFoods){
  const alive = new Set(currentFoods.map(foodKey));
  for(const k of foodVis.keys()){
    if(!alive.has(k)) foodVis.delete(k);
  }
}
const FOOD_POP_MS = 380;

function foodKey(f){
  const x = (f && typeof f.x === "number") ? f.x : 0;
  const y = (f && typeof f.y === "number") ? f.y : 0;
  const k = f?.kind || "";
  const c = f?.color || "";
  const s = (typeof f?.size === "number") ? f.size : 1;
  return `${x}|${y}|${k}|${c}|${s}`;
}
function markFoodBirths(newFoods, timeMs){
  for(const f of (newFoods || [])){
    if(f?.kind !== "corpse") continue;
    const key = foodKey(f);
    if(!foodBirth.has(key)) foodBirth.set(key, timeMs);
  }
  if(!markFoodBirths._nextClean) markFoodBirths._nextClean = timeMs + 2000;
  if(timeMs < markFoodBirths._nextClean) return;
  markFoodBirths._nextClean = timeMs + 2000;
  const cutoff = timeMs - 8000;
  for(const [k, born] of foodBirth.entries()){
    if(born < cutoff) foodBirth.delete(k);
  }
}
function easeOutCubic(t){
  t = Math.max(0, Math.min(1, t));
  return 1 - Math.pow(1 - t, 3);
}

const FOOD_WOBBLE_PX = 7.5;
const FOOD_WOBBLE_SPEED = 0.0036;

/* VACUUM visual (close-range ONLY) ‚Äî tighter + stronger on PC */
const SUCTION_RADIUS   = 22;
const SUCTION_KILL     = 7;
const SUCTION_PULL_PX  = 6.2;

function hash01(str){
  let h = 2166136261;
  for(let i=0;i<str.length;i++){
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return ((h >>> 0) % 100000) / 100000;
}

/* DRAW LOOP */
function draw(ts){
  requestAnimationFrame(draw);
  if(canvas.style.display==="none") return;

  updateRafHz(ts);

  const newCap = getCapHz();
  if(newCap !== capHz) capHz = newCap;
  const stepMs = 1000 / capHz;

  if(draw._lastRafTs == null){
    draw._lastRafTs = ts;
    draw._acc = 0;
  }
  let dt = ts - draw._lastRafTs;
  draw._lastRafTs = ts;
  if(dt > 120) dt = 120;
  draw._acc += dt;
  if(draw._acc < stepMs) return;
  draw._acc -= stepMs;

  const dtFrame = stepMs;
  const timeMs = ts;

  updateFpsOnRenderedFrame(timeMs);
  drawBackground();

  const renderPlayers = {};
  const renderTime = timeMs - INTERP_DELAY_MS;

  const meR = remote[playerId];
  if(meR && meR.snaps && meR.snaps.length){
    const meI = interpSnakeFromSnaps(meR.snaps, renderTime);
    if(meI && meI.length){
      const meSmoothTau = isTouchDevice ? 88 : 35;
      const alphaMe = 1 - Math.exp(-dtFrame / meSmoothTau);
      const smoothMe = smoothSnake(playerId, meI, alphaMe);
      renderPlayers[playerId] = { snake: smoothMe, boost: !!meR.boost, color: meR.color || "white" };
    }
  }

  for(const id in remote){
    if(id === playerId) continue;
    const r = remote[id];
    if(!r || !r.snaps || !r.snaps.length) continue;

    const sI = interpSnakeFromSnaps(r.snaps, renderTime);
    if(!sI || sI.length < 2) continue;

    const n = sI.length;
    const tau = Math.min(260, 180 + n * 0.18);
    const alpha = 1 - Math.exp(-dtFrame / tau);
    const smooth = smoothSnake(id, sI, alpha);

    renderPlayers[id] = { snake: smooth, boost: !!r.boost, color: r.color || "white" };
  }

  const meRender = renderPlayers[playerId]?.snake || null;

  if(!dead && meRender && meRender.length){
    const h = meRender[0];
    if(lastMeHead && lastMeHeadTs != null){
      const dtv = Math.max(1, timeMs - lastMeHeadTs);
      lastMeVel.vx = (h.x - lastMeHead.x) / dtv;
      lastMeVel.vy = (h.y - lastMeHead.y) / dtv;
    }
    lastMeHead = { x: h.x, y: h.y };
    lastMeHeadTs = timeMs;
  }

  const boostActive = !!renderPlayers[playerId]?.boost;

  hud.textContent =
`–†–µ–∂–∏–º: ${useTouch ? "–º–æ–± (–¥–∂–æ–π—Å—Ç–∏–∫)" : (useMouse ? "–º—ã—à—å" : "–∫–ª–∞–≤–∞ (A/D —Ä—É–ª–∏—Ç, W –±—ã—Å—Ç—Ä–µ–µ, S —Ç–æ—á–Ω–µ–µ)")}
FPS: ${fps} | Cap: ${Math.round(capHz)} | RTT‚âà${Math.round(rtt)}ms | –£—Å–∫–æ—Ä–µ–Ω–∏–µ: ${boostActive ? "–≤–∫–ª" : "–≤—ã–∫–ª"} | M/–¨: —Ä–µ–∂–∏–º (–ü–ö)`;

  updateCamera(meRender);
  cleanupFoodVis(foods);

  /* FOOD DRAW */
  let corpseGlowBudget = lowDetail ? 0 : 120;
  const foodStep = lowDetail ? 2 : 1;

  for(let i=0;i<foods.length;i+=foodStep){
    const f = foods[i];
    const mult = (typeof f.size === "number") ? f.size : 1;
    const isCorpse = (f.kind === "corpse");

    let alphaMul = 1.0;
    let scaleMul = 1.0;

    if(isCorpse){
      const key0 = foodKey(f);
      const born = foodBirth.get(key0);
      if(typeof born === "number"){
        const t = (timeMs - born) / FOOD_POP_MS;
        const kk = easeOutCubic(t);
        alphaMul = 0.10 + 0.90 * kk;
        scaleMul = 0.72 + 0.28 * kk;
      }
    }

    let tx = f.x;
    let ty = f.y;

    const key = foodKey(f);
    const seed = hash01(key);

    // –æ–±—ã—á–Ω–∞—è –µ–¥–∞ —á—É—Ç—å –ø–ª–∞–≤–∞–µ—Ç, corpse ‚Äî –ø–æ –ø–æ–∑–∏—Ü–∏–∏ —Å—Ç–æ–∏—Ç (–Ω–æ —Å–≤–µ—Ç–∏—Ç—Å—è)
    if(!isCorpse){
      const t0 = timeMs * FOOD_WOBBLE_SPEED + seed * 10.0;
      const t1 = timeMs * (FOOD_WOBBLE_SPEED * 0.55) + seed * 3.0;

      tx += (Math.sin(t0) + 0.55*Math.sin(t1 + 1.3)) * (FOOD_WOBBLE_PX * 0.70);
      ty += (Math.cos(t0 * 0.92 + 1.7) + 0.55*Math.cos(t1 * 0.88 + 2.2)) * (FOOD_WOBBLE_PX * 0.70);
    }

    let suctionK = 0;

    if(meRender && meRender.length){
      const hx = meRender[0].x, hy = meRender[0].y;
      const dxh = hx - tx, dyh = hy - ty;
      const dist = Math.hypot(dxh, dyh) || 1;

      if(dist < SUCTION_RADIUS){
        suctionK = smoothstep01(1 - (dist / SUCTION_RADIUS));
        const inv = 1 / dist;
        const ux = dxh * inv, uy = dyh * inv;

        const pcMul = isTouchDevice ? 1.0 : 1.45;
        const maxStep = SUCTION_PULL_PX * pcMul * (0.20 + 1.10*suctionK);
        const need = Math.max(0, dist - SUCTION_KILL);
        const step = Math.min(maxStep, need);

        tx += ux * step;
        ty += uy * step;

        if(dist < SUCTION_KILL){
          const snap = smoothstep01(1 - dist / SUCTION_KILL);
          tx = lerp(tx, hx, snap);
          ty = lerp(ty, hy, snap);
        }
      }
    }

    const vis = getFoodVis(key, tx, ty);
    const tau = lerp(95, 55, suctionK);
    const kL = expLerpFactor(dtFrame, tau);

    vis.x = vis.x + (tx - vis.x) * kL;
    vis.y = vis.y + (ty - vis.y) * kL;

    const x = sx(vis.x);
    const y = sy(vis.y);

    let visualMul = 1.0;
    if(f.kind === "base") visualMul = 0.68;
    else if(f.kind === "drop") visualMul = 0.62;
    else if(f.kind === "corpse") visualMul = 0.70;

    const baseR0 = (SEGMENT/4) * mult * visualMul * Math.sqrt(SNAKE_SCALE);
    const baseR = baseR0 * scaleMul * VIEW_ZOOM;

    const col = f.color || (isCorpse ? "white" : "lime");

    ctx.save();

    if(isCorpse){
      // –ø—É–ª—å—Å —Å–≤–µ—á–µ–Ω–∏—è (corpse –ø–æ –ø–æ–∑–∏—Ü–∏–∏ —Å—Ç–æ–∏—Ç)
      const pulse = 0.65 + 0.35*Math.sin(timeMs * 0.008 + seed * 6.0);
      ctx.globalAlpha = alphaMul;
      if(corpseGlowBudget > 0){
        corpseGlowBudget--;
        ctx.shadowColor = col;
        ctx.shadowBlur = (12 * scaleMul) * (0.85 + 0.85*pulse);
      } else {
        ctx.shadowBlur = 0;
      }
    } else {
      ctx.globalAlpha = 1.0;
      ctx.shadowBlur = 0;
    }

    ctx.save();
    ctx.globalAlpha *= isCorpse ? 0.75 : 0.55;
    ctx.fillStyle = col;
    ctx.beginPath();
    ctx.arc(x, y, baseR * 1.35, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.fillStyle = col;
    ctx.beginPath();
    ctx.arc(x, y, baseR, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  for(const id in renderPlayers){
    const rp = renderPlayers[id];
    drawSnakeRibbon(rp.snake, rp.color, rp.boost, id === playerId, timeMs);
  }

  // –ö—Ä–∞—Å–Ω–∞—è —Ä–∞–º–∫–∞ –º–∏—Ä–∞ ‚Äî —Ç–æ–ª—å–∫–æ –≤ –∏–≥—Ä–µ (–∫–æ–≥–¥–∞ –º–µ–Ω—é —Å–∫—Ä—ã—Ç–æ)
  const inGame = (menu.style.display === "none");
  if(inGame){
    ctx.save();
    ctx.strokeStyle="red";
    ctx.lineWidth=4;
    ctx.strokeRect(
      sx(0) - SEGMENT/2,
      sy(0) - SEGMENT/2,
      WORLD_W * VIEW_ZOOM,
      WORLD_H * VIEW_ZOOM
    );
    ctx.restore();
  }

  if(dead && deathAtMs != null){
    const k = smoothstep01((timeMs - deathAtMs) / DEATH_FADE_MS);
    const a = 0.85 * k;
    ctx.save();
    ctx.fillStyle = `rgba(0,0,0,${a})`;
    ctx.fillRect(0,0,VIEW_W,VIEW_H);
    ctx.restore();
  }
}

/* START / WS */
const td = new TextDecoder();

function cloneSnakePoints(s){
  if(!s || !s.length) return null;
  return s.map(p => ({x: p.x, y: p.y}));
}

function startGame(){
  if(deathMenuTimer){ clearTimeout(deathMenuTimer); deathMenuTimer = null; }

  dead = false;
  deathAtMs = null;

  lastMeHead = null;
  lastMeHeadTs = null;
  lastMeVel = {vx:0, vy:0};

  SNAKE_SCALE = isTouchDevice ? MOBILE_SNAKE_SCALE : DESKTOP_SNAKE_SCALE;

  dir = {x:1,y:0};
  initHeadingFromVector({x:1,y:0});

  foods = [];
  for(const k in remote) delete remote[k];
  for(const k in renderCache) delete renderCache[k];
  foodBirth.clear();
  foodVis.clear();
  keysDown.clear();
  serverBoosting = false;

  lastSent = 0;
  lastDirSent = {x:1, y:0};
  lastAxisX = 1;
  lastAxisY = -1;

  cameraX = 0; cameraY = 0;
  camHX = camHY = null;

  menu.style.display="none";
  canvas.style.display="block";
  hud.style.display="block";

  useTouch = !!isTouchDevice;
  VIEW_ZOOM = isTouchDevice ? MOBILE_VIEW_ZOOM : 1;

  if(!useTouch){
    useMouse = true;
    mouseTargetHeading = heading;
  }

  if(useTouch){
    useMouse = false;
    touchUI.style.display = "block";
    touchUI.setAttribute("aria-hidden","false");
  } else {
    touchUI.style.display = "none";
    touchUI.setAttribute("aria-hidden","true");
  }

  fitCanvas();
  canvas.focus();

  playerId="player"+Math.floor(Math.random()*9999);
  ws=new WebSocket(wsUrl(`/ws/${ROOM_ID}/${playerId}`));
  ws.binaryType = "arraybuffer";

  ws.onopen = () => { startRttPing(); startInputHeartbeat(); };

  ws.onmessage = async (e) => {
    let data = null;

    if(e.data instanceof ArrayBuffer){
      const txt = td.decode(new Uint8Array(e.data));
      data = JSON.parse(txt);
    } else if(typeof e.data === "string") {
      data = JSON.parse(e.data);
    } else {
      return;
    }

    if (data.type === "pong") {
      const now = performance.now();
      const sample = Math.max(0, now - (data.t || now));
      rtt = rtt*0.8 + sample*0.2;
      return;
    }

    if (data.type === "death") {
      dead = true;
      sendBoost(false);

      const now = performance.now();
      if(deathAtMs == null) deathAtMs = now;

      if(deathMenuTimer) clearTimeout(deathMenuTimer);
      deathMenuTimer = setTimeout(()=>{
        try{ ws?.close?.(); } catch(_e){}
        canvas.style.display="none";
        hud.style.display="none";
        menu.style.display="flex";
      }, DEATH_HOLD_MS);

      return;
    }

    if (data.type === "snapshot") {
      const pl = data.players || {};
      for(const id in pl){
        const it = pl[id];
        const r = remote[id] || (remote[id] = { path: [], bodyKF:null, lastV: 0, len: 10, lenF: 10, boost:0, color:"white", head:null, dir:null, dirS:null, lastNetTs:null, snaps: [] });
        r.color = it.color || r.color;
        r.boost = !!it.boost;
      }
      if (Array.isArray(data.foods)) {
        foods = data.foods;
        markFoodBirths(foods, performance.now());
      }
      return;
    }

    if (data.type === "state" && data.players) {
      const pl = data.players;

      const seen = new Set(Object.keys(pl));
      for(const id in remote){
        if(id === playerId) continue;
        if(!seen.has(id)) delete remote[id];
      }

      const nowMs = performance.now();

      for(const id in pl){
        const it = pl[id];
        const r = remote[id] || (remote[id] = { path: [], bodyKF:null, lastV: 0, len: 10, lenF: 10, boost:0, color:"white", head:null, dir:null, dirS:null, lastNetTs:null, snaps: [] });

        r.lenF = (typeof it.lf === "number") ? it.lf : (it.l|0);
        r.len  = it.l|0;
        r.boost = !!it.b;
        r.color = it.c || r.color;

        if(Array.isArray(it.h)) r.head = { x: it.h[0], y: it.h[1] };
        if(Array.isArray(it.u)) r.dir  = { x: it.u[0], y: it.u[1] };

        const hasKF = !!it.kf && Array.isArray(it.body) && it.body.length >= 4;
        let skipPtThisTick = false;

        if (hasKF) {
          r.bodyKF = it.body;
          const kfSnake = snakePointsFromFlatBody(it.body);
          r.path = kfSnake.slice();
          r.lastV = (it.pv | 0);

          const netSnake = buildSnakeFromPath(r.path, r.lenF);
          pushSnap(r, netSnake, nowMs);

          skipPtThisTick = true;
        }

        if (!skipPtThisTick && Array.isArray(it.pt) && it.pt.length) {
          const basePrevV = (r.lastV | 0);

          let maxV = (r.lastV | 0);
          const newPts = [];

          for (let j = 0; j < it.pt.length; j++) {
            const n = it.pt[j];
            const v = n[0] | 0;
            if (v <= basePrevV) continue;

            const x = +n[1], y = +n[2];

            if (r.path && r.path.length) {
              const hx = r.path[0].x, hy = r.path[0].y;
              const dx = x - hx, dy = y - hy;
              if (dx*dx + dy*dy < 0.01) {
                if (v > maxV) maxV = v;
                continue;
              }
            }

            newPts.push({ x, y, v });
            if (v > maxV) maxV = v;
          }

          for (let k = newPts.length - 1; k >= 0; k--) {
            r.path.unshift({ x: newPts[k].x, y: newPts[k].y });
          }

          if (r.path.length > REMOTE_PATH_MAX) r.path.length = REMOTE_PATH_MAX;
          r.lastV = maxV;

          let sourcePath = (r.path && r.path.length >= 2) ? r.path : null;
          if(!sourcePath && Array.isArray(r.bodyKF) && r.bodyKF.length >= 4){
            sourcePath = snakePointsFromFlatBody(r.bodyKF);
          }
          if(sourcePath && sourcePath.length >= 2){
            const netSnake = buildSnakeFromPath(sourcePath, r.lenF);
            pushSnap(r, netSnake, nowMs);
          }
        }

        r.lastNetTs = nowMs;
      }

      if (Array.isArray(data.foods)) {
        foods = data.foods;
        markFoodBirths(foods, performance.now());
      }
    }
  };

  ws.onclose = () => {
    if(rttTimer){ clearInterval(rttTimer); rttTimer = null; }
    if(inputTimer){ clearInterval(inputTimer); inputTimer = null; }
    sendBoost(false);
    touchUI.style.display = "none";
    touchUI.setAttribute("aria-hidden","true");

    if(dead) return;

    canvas.style.display="none";
    hud.style.display="none";
    menu.style.display="flex";
  };
}

/* PC input */
canvas.addEventListener("mousemove", e=>{
  if(useTouch) return;
  if(!useMouse) return;
  if(dead) return;
  const me = remote[playerId];
  if(!me) return;

  let hx = null, hy = null;
  if(me.path && me.path.length) { hx = me.path[0].x; hy = me.path[0].y; }
  else if(Array.isArray(me.bodyKF) && me.bodyKF.length >= 2) { hx = me.bodyKF[0]; hy = me.bodyKF[1]; }
  if(hx == null) return;

  const mx = (e.clientX / VIEW_ZOOM) + cameraX - hx;
  const my = (e.clientY / VIEW_ZOOM) + cameraY - hy;
  if(Math.abs(mx) + Math.abs(my) < 0.001) return;
  mouseTargetHeading = Math.atan2(my, mx);
});

document.addEventListener("keydown", e=>{
  if(useTouch) return;
  const k = (e.key || "").toLowerCase();
  if(k === "m" || k === "—å"){
    useMouse = !useMouse;
    keysDown.clear();
    mouseTargetHeading = heading;
    e.preventDefault?.();
  }
});

function updateAxisOnPress(k){
  if(k === "a") lastAxisX = -1;
  if(k === "d") lastAxisX =  1;
  if(k === "w") lastAxisY = -1;
  if(k === "s") lastAxisY =  1;
}

document.addEventListener("keydown", e=>{
  if(useTouch) return;
  if(dead) return;
  const k = normKey(e.key);
  if(k === " " || k === "space" || e.code === "Space"){
    sendBoost(true);
    e.preventDefault?.();
    return;
  }
  if(k === "w" || k === "a" || k === "s" || k === "d"){
    if(!keysDown.has(k)){
      keysDown.add(k);
      updateAxisOnPress(k);
    }
    e.preventDefault?.();
  }
});

document.addEventListener("keyup", e=>{
  if(useTouch) return;
  const k = normKey(e.key);
  if(k === " " || k === "space" || e.code === "Space"){
    sendBoost(false);
    e.preventDefault?.();
    return;
  }
  if(k === "w" || k === "a" || k === "s" || k === "d"){
    keysDown.delete(k);
    e.preventDefault?.();
  }
});

window.addEventListener("blur", () => sendBoost(false));
document.addEventListener("visibilitychange", () => { if(document.hidden) sendBoost(false); });

/* mobile joystick + boost */
const joy = { active:false, pid:null, radius:62, x:0, y:0 };
function setKnob(dx, dy){ joyKnob.style.transform = `translate(${dx}px, ${dy}px)`; }
function joyReset(){
  joy.active = false; joy.pid = null;
  joy.x = joy.y = 0; setKnob(0,0);
  touchTargetHeading = heading;
}
function joyUpdateFromPointer(clientX, clientY) {
  const rect = joyWrap.getBoundingClientRect();
  const cx = rect.left + rect.width / 2;
  const cy = rect.top + rect.height / 2;
  const dx0 = clientX - cx;
  const dy0 = clientY - cy;
  const r = joy.radius;
  const len = Math.hypot(dx0, dy0);
  let dx = dx0, dy = dy0;

  // –û–≥—Ä–∞–Ω–∏—á–∏–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–¥–∏—É—Å –¥–∂–æ–π—Å—Ç–∏–∫–∞, –µ—Å–ª–∏ –æ–Ω –ø—Ä–µ–≤—ã—à–∞–µ—Ç –µ–≥–æ —Ä–∞–¥–∏—É—Å
  if (len > r) {
    const k = r / len; dx *= k; dy *= k;
  }
  joy.x = dx; joy.y = dy;
  setKnob(dx, dy);

  // –û–±–Ω–æ–≤–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–∞–Ω–∏–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏ –¥–∂–æ–π—Å—Ç–∏–∫–∞
  if (Math.abs(dx) + Math.abs(dy) < 2) {
    touchTargetHeading = heading;
    return;
  }
  touchTargetHeading = Math.atan2(dy, dx);
}

joyWrap.addEventListener("pointerdown", (e)=>{
  if(!useTouch) return;
  if(dead) return;
  joy.active = true;
  joy.pid = e.pointerId;
  joyWrap.setPointerCapture(e.pointerId);
  joyUpdateFromPointer(e.clientX, e.clientY);
  e.preventDefault();
}, {passive:false});

joyWrap.addEventListener("pointermove", (e)=>{
  if(!useTouch || !joy.active) return;
  if(e.pointerId !== joy.pid) return;
  joyUpdateFromPointer(e.clientX, e.clientY);
  e.preventDefault();
}, {passive:false});

function joyEnd(e){
  if(!useTouch || !joy.active) return;
  if(e && e.pointerId != null && e.pointerId !== joy.pid) return;
  joyReset();
  e?.preventDefault?.();
}
joyWrap.addEventListener("pointerup", joyEnd, {passive:false});
joyWrap.addEventListener("pointercancel", joyEnd, {passive:false});
joyWrap.addEventListener("lostpointercapture", joyEnd, {passive:false});

function bindHoldButton(btn, onDown, onUp){
  btn.addEventListener("pointerdown", (e)=>{ if(!useTouch) return; onDown(); btn.setPointerCapture(e.pointerId); e.preventDefault(); }, {passive:false});
  btn.addEventListener("pointerup",   (e)=>{ if(!useTouch) return; onUp();   e.preventDefault(); }, {passive:false});
  btn.addEventListener("pointercancel",(e)=>{ if(!useTouch) return; onUp();  e.preventDefault(); }, {passive:false});
  btn.addEventListener("lostpointercapture",(e)=>{ if(!useTouch) return; onUp(); e.preventDefault(); }, {passive:false});
}
bindHoldButton(boostBtn, ()=>sendBoost(true), ()=>sendBoost(false));

/* START */
playBtn.addEventListener("click", startGame);
fitCanvas();
requestAnimationFrame(draw);
</script>
</body>
</html>
