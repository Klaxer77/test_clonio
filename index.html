<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Snake Smooth Multiplayer</title>
  <style>
    html,body{margin:0;padding:0;overflow:hidden;font-family:Arial,sans-serif;background: linear-gradient(135deg, #1a1a1a 0%, #111 100%);color:white;}
    canvas{display:block;outline:none;}
    #menu{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;background: rgba(0,0,0,0.82);gap:14px;text-align:center;padding:24px;box-sizing:border-box;}
    button{font-size:24px;padding:15px 40px;cursor:pointer;border:none;background:lime;color:black;border-radius:10px;}
    button:hover{background:#7CFF7C;}
    .hud{position:fixed;left:12px;top:10px;z-index:5;font-size:14px;opacity:.85;user-select:none;pointer-events:none;text-shadow:0 1px 2px rgba(0,0,0,.6);line-height:1.35;white-space:pre;}
  </style>
</head>
<body>
  <div id="menu">
    <h1>üêç Snake</h1>
    <button id="playBtn">–ò–≥—Ä–∞—Ç—å</button>
  </div>

  <div id="hud" class="hud" style="display:none"></div>
  <canvas id="game" tabindex="0"></canvas>

<script>
const WORLD_W = 3000, WORLD_H = 3000;
const SEGMENT = 30;
const ROOM_ID = "room1";

const CLIENT_SPEED = 4;

/* ===== server speed model (match server!) ===== */
const SERVER_TICK_SEC = 0.025;
const SERVER_SPEED = 7;
const SERVER_BOOST_MULT = 1.8;

const SPEED_BASE_PX_S  = SERVER_SPEED / SERVER_TICK_SEC;
const SPEED_BOOST_PX_S = (SERVER_SPEED * SERVER_BOOST_MULT) / SERVER_TICK_SEC;

let predDirUnit = {x:1, y:0};
let lastTurnTs = 0;
const TURN_MIN_MS = 55;

let ws=null, playerId=null, players={}, foods=[], cameraX=0, cameraY=0;
let dir = {x:1, y:0}, dead=false;
let useMouse = false;

let serverBoosting = false;
const keysDown = new Set();

/* ===== FIX: axis priority without key-repeat jitter ===== */
let lastAxisX = 1;   // 1 => right, -1 => left
let lastAxisY = -1;  // 1 => down,  -1 => up

const menu=document.getElementById("menu"),
      playBtn=document.getElementById("playBtn"),
      canvas=document.getElementById("game"),
      hud=document.getElementById("hud"),
      ctx=canvas.getContext("2d");

function wsUrl(path){
  const proto = (location.protocol === "https:") ? "wss" : "ws";
  return `${proto}://${location.host}${path}`;
}

function clamp01(v){ return Math.max(-1, Math.min(1, v)); }
function lerp(a,b,t){ return a + (b-a)*t; }

/* =========================
   SCALE
========================= */
const SNAKE_SCALE = 1.35;
let GRID_STEP = Math.round(SEGMENT * 2.4);

/* =========================
   FPS METER
========================= */
let fps = 60;
let lastFpsTs = performance.now();
let frames = 0;
let lowDetail = false;

function updateFpsOnRenderedFrame(timeMs){
  frames++;
  const dt = timeMs - lastFpsTs;
  if(dt >= 500){
    fps = Math.round((frames * 1000) / dt);
    frames = 0;
    lastFpsTs = timeMs;

    lowDetail = fps < 45;
    GRID_STEP = Math.round(SEGMENT * (lowDetail ? 3.2 : 2.4));
  }
}

/* =========================
   RTT ping/pong
========================= */
let rtt = 60;
let rttTimer = null;

function startRttPing(){
  if(rttTimer) clearInterval(rttTimer);
  rttTimer = setInterval(()=>{
    if(!ws || ws.readyState !== 1) return;
    ws.send(JSON.stringify({type:"ping", t: performance.now()}));
  }, 800);
}

/* =========================
   ADAPTIVE FPS CAP + SNAP TIMING
========================= */
const TARGET_CAP = 75;
const SERVER_TICK_MS = 25;
const PLAYERS_SEND_EVERY = 1;
const SNAP_INTERVAL_MS = SERVER_TICK_MS * PLAYERS_SEND_EVERY;
const MIN_INTERP_MS = Math.max(55, Math.ceil(SNAP_INTERVAL_MS * 2.2));

const rafMeter = { lastTs: null, samples: [], maxSamples: 90, hz: 60 };

function updateRafHz(ts){
  if(rafMeter.lastTs == null){ rafMeter.lastTs = ts; return; }
  const dt = ts - rafMeter.lastTs;
  rafMeter.lastTs = ts;
  if(dt <= 0) return;

  const instHz = 1000 / dt;
  if(instHz < 10 || instHz > 400) return;

  rafMeter.samples.push(instHz);
  if(rafMeter.samples.length > rafMeter.maxSamples) rafMeter.samples.shift();

  const a = rafMeter.samples.slice().sort((x,y)=>x-y);
  const mid = a.length >> 1;
  const med = a.length ? (a.length % 2 ? a[mid] : (a[mid-1]+a[mid])/2) : 60;

  const snap = (v) => {
    const presets = [50, 60, 75, 90, 100, 120, 144, 165, 180, 240];
    let best = v, bestD = 1e9;
    for(const p of presets){
      const d = Math.abs(v - p);
      if(d < bestD){ bestD = d; best = p; }
    }
    return (bestD <= 3.0) ? best : v;
  };
  rafMeter.hz = snap(med);
}

let capHz = 60;
function getCapHz(){
  return Math.min(rafMeter.hz || 60, TARGET_CAP);
}

/* =========================
   RENDER SMOOTH (DT-AWARE)
========================= */
const renderCache = {};
function smoothSnake(id, targetSnake, alpha){
  if(!targetSnake || targetSnake.length === 0) return targetSnake;

  const prev = renderCache[id];
  if(!prev || prev.length === 0){
    renderCache[id] = targetSnake.map(p => ({x:p.x, y:p.y}));
    return renderCache[id];
  }

  const n = targetSnake.length;
  const out = new Array(n);
  for(let i=0;i<n;i++){
    const tp = targetSnake[i];
    const pp = prev[i] || prev[prev.length - 1] || tp;
    out[i] = { x: lerp(pp.x, tp.x, alpha), y: lerp(pp.y, tp.y, alpha) };
  }

  renderCache[id] = out;
  return out;
}

/* =========================
   SNAPSHOTS (OTHERS)
========================= */
const snapshots = {};
const SNAP_MAX = 18;

function pushSnapshot(id, pl){
  const t = performance.now();
  const q = snapshots[id] || (snapshots[id] = []);
  q.push({
    t,
    snake: (pl.snake || []).map(p => ({x:p.x, y:p.y})),
    boost: !!pl.boost,
    color: pl.color || "white"
  });
  while(q.length > SNAP_MAX) q.shift();
}

function cleanupSnapshots(){
  for(const id in snapshots){
    if(!players[id]) delete snapshots[id];
  }
}

function sampleInterpSnake(id, renderTime){
  const q = snapshots[id];
  if(!q || q.length === 0) return null;
  if(q.length === 1) return {snake: q[0].snake, boost:q[0].boost, color:q[0].color};

  let a = null, b = null;
  for(let i=0;i<q.length-1;i++){
    if(q[i].t <= renderTime && renderTime <= q[i+1].t){
      a = q[i]; b = q[i+1]; break;
    }
  }

  if(!a || !b){
    if(renderTime < q[0].t) return {snake:q[0].snake, boost:q[0].boost, color:q[0].color};
    return {snake:q[q.length-1].snake, boost:q[q.length-1].boost, color:q[q.length-1].color};
  }

  const dt = (b.t - a.t);
  const k = dt <= 1 ? 0 : clamp01((renderTime - a.t) / dt);

  const n = Math.max(a.snake.length, b.snake.length);
  if(n === 0) return {snake:[], boost:b.boost, color:b.color};

  const out = new Array(n);
  for(let i=0;i<n;i++){
    const pa = a.snake[i] || a.snake[a.snake.length-1];
    const pb = b.snake[i] || b.snake[b.snake.length-1];
    out[i] = {x: lerp(pa.x, pb.x, k), y: lerp(pa.y, pb.y, k)};
  }

  return {snake: out, boost: b.boost, color: b.color};
}

/* =========================
   ME: LOCAL PREDICTION
========================= */
let meBaseSnake = null;
let meBaseHead  = null;
let mePredHead  = null;
let meLastPredTs = null;
let meBaseBoost = false;

/* =========================
   DEATH FLOW
========================= */
let isDying = false;
let deathPhase = "none";
let deathTimer = 0;
let deathFade = 0;

const DEATH_FREEZE_MS = 900;
const DEATH_FADE_MS   = 650;

let gotPostDeathState = false;
const POST_DEATH_STATE_TIMEOUT_MS = 600;
let postDeathWaitMs = 0;

function resetDeathFlow(){
  isDying = false;
  deathPhase = "none";
  deathTimer = 0;
  deathFade = 0;
  gotPostDeathState = false;
  postDeathWaitMs = 0;
  draw._lastDeathTs = null;
}

function showMenuAfterDeath(){
  canvas.style.display="none";
  hud.style.display="none";
  menu.style.display="flex";
}

/* =========================
   FOOD SPAWN ANIM (light)
========================= */
const foodBirth = new Map();
const FOOD_POP_MS = 380;

function foodKey(f){
  const x = (f && typeof f.x === "number") ? f.x : 0;
  const y = (f && typeof f.y === "number") ? f.y : 0;
  const k = f?.kind || "";
  const c = f?.color || "";
  const s = (typeof f?.size === "number") ? f.size : 1;
  return `${x}|${y}|${k}|${c}|${s}`;
}

function markFoodBirths(newFoods, timeMs){
  for(const f of (newFoods || [])){
    if(f?.kind !== "corpse") continue;
    const key = foodKey(f);
    if(!foodBirth.has(key)) foodBirth.set(key, timeMs);
  }

  if(!markFoodBirths._nextClean) markFoodBirths._nextClean = timeMs + 2000;
  if(timeMs < markFoodBirths._nextClean) return;
  markFoodBirths._nextClean = timeMs + 2000;

  const cutoff = timeMs - 8000;
  for(const [k, born] of foodBirth.entries()){
    if(born < cutoff) foodBirth.delete(k);
  }
}

function easeOutCubic(t){
  t = Math.max(0, Math.min(1, t));
  return 1 - Math.pow(1 - t, 3);
}

/* =========================
   CONTROL
========================= */
let lastSent = 0;
let lastDirSent = {x:1, y:0};
let wantDirUnit = {x:1, y:0};

function setDirection(newDir){
  const len = Math.hypot(newDir.x,newDir.y);
  if(len===0) return;

  const nx = newDir.x/len;
  const ny = newDir.y/len;

  const now = performance.now();

  const dx = nx - wantDirUnit.x;
  const dy = ny - wantDirUnit.y;
  const changed = (dx*dx + dy*dy) > 0.0009;

  if(changed && (now - lastTurnTs) < TURN_MIN_MS){
    return;
  }
  if(changed) lastTurnTs = now;

  wantDirUnit = {x:nx, y:ny};
  dir = {x: nx*CLIENT_SPEED, y: ny*CLIENT_SPEED};
  sendDirection(nx, ny);
}

function sendDirection(nx, ny){
  if(!ws) return;
  if(isDying || dead) return;
  if(ws.readyState !== 1) return;

  const now = performance.now();

  const dx = nx - lastDirSent.x;
  const dy = ny - lastDirSent.y;
  const changed = (dx*dx + dy*dy) > 0.0009;

  if(!changed && (now - lastSent) < 140) return;
  if((now - lastSent) < 14) return;

  lastSent = now;
  lastDirSent = {x:nx, y:ny};
  ws.send(JSON.stringify({direction: {x: nx, y: ny}}));
}

function sendBoost(state){
  if(!ws) return;
  if(ws.readyState !== 1) return;
  if(state === serverBoosting) return;
  serverBoosting = state;
  ws.send(JSON.stringify({boost: state}));
}

let inputTimer = null;
function startInputHeartbeat(){
  if(inputTimer) clearInterval(inputTimer);
  inputTimer = setInterval(()=>{
    if(!ws || ws.readyState !== 1) return;
    if(isDying || dead) return;

    if(!useMouse){
      applyKeyboardVector(true);
    } else {
      sendDirection(wantDirUnit.x, wantDirUnit.y);
    }
  }, 40);
}

/* =========================
   CAMERA
========================= */
let camHX = null, camHY = null;
const CAM_SMOOTH = 0.18;

function updateCamera(renderMeSnake){
  if(!renderMeSnake || renderMeSnake.length === 0) return;
  const h = renderMeSnake[0];
  if(camHX === null){ camHX = h.x; camHY = h.y; }
  camHX = camHX + (h.x - camHX) * CAM_SMOOTH;
  camHY = camHY + (h.y - camHY) * CAM_SMOOTH;
  cameraX = camHX - canvas.width/2;
  cameraY = camHY - canvas.height/2;
}

/* =========================
   RENDER HELPERS
========================= */
const BODY_WIDTH = SEGMENT * 0.95 * SNAKE_SCALE;
const HEAD_RADIUS = (BODY_WIDTH * 0.50);

const EYE_WHITE_R = HEAD_RADIUS * 0.38;
const EYE_PUPIL_R = EYE_WHITE_R * 0.45;
const PUPIL_SHIFT = EYE_WHITE_R * 0.35;

function drawSnakeEyes(s, look){
  if(!s || s.length < 2) return;

  const h = s[0];
  const n = s[1];

  let fx = h.x - n.x;
  let fy = h.y - n.y;
  const fl = Math.hypot(fx, fy) || 1;
  fx /= fl; fy /= fl;

  const lx = -fy;
  const ly = fx;

  const cx = h.x - cameraX + SEGMENT/2;
  const cy = h.y - cameraY + SEGMENT/2;

  const side = HEAD_RADIUS * 0.55;
  const fwd  = HEAD_RADIUS * 0.20;

  const ex1 = cx + lx*side + fx*fwd;
  const ey1 = cy + ly*side + fy*fwd;
  const ex2 = cx - lx*side + fx*fwd;
  const ey2 = cy - ly*side + fy*fwd;

  let dx = look?.x ?? fx;
  let dy = look?.y ?? fy;
  const dl = Math.hypot(dx, dy) || 1;
  dx /= dl; dy /= dl;

  const lookF = clamp01(dx*fx + dy*fy);
  const lookL = clamp01(dx*lx + dy*ly);

  const pxShiftX = fx*(lookF*PUPIL_SHIFT) + lx*(lookL*PUPIL_SHIFT);
  const pxShiftY = fy*(lookF*PUPIL_SHIFT) + ly*(lookL*PUPIL_SHIFT);

  ctx.save();
  ctx.fillStyle = "white";
  ctx.beginPath(); ctx.arc(ex1, ey1, EYE_WHITE_R, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(ex2, ey2, EYE_WHITE_R, 0, Math.PI*2); ctx.fill();

  ctx.fillStyle = "black";
  ctx.beginPath(); ctx.arc(ex1 + pxShiftX, ey1 + pxShiftY, EYE_PUPIL_R, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(ex2 + pxShiftX, ey2 + pxShiftY, EYE_PUPIL_R, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

function decimate(points, step){
  if(step <= 1) return points;
  const out = [];
  for(let i=0;i<points.length;i+=step) out.push(points[i]);
  if(points.length && out[out.length-1] !== points[points.length-1]) out.push(points[points.length-1]);
  return out;
}

function drawSnakeRibbon(renderSnake, color, boost, isMe, timeMs){
  const base = renderSnake || [];
  if(base.length < 2) return;

  const s = isMe ? base : decimate(base, lowDetail ? 3 : 2);

  if(boost){
    const pulse1 = 0.5 + 0.5*Math.sin(timeMs * 0.022);
    const pulse2 = 0.5 + 0.5*Math.sin(timeMs * 0.017 + 1.2);

    const glowAlpha = lowDetail ? 0.10 : (0.16 + 0.10*pulse1);
    const glowW = BODY_WIDTH * ((isMe ? 2.10 : 1.95) + 0.45*pulse2);

    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.strokeStyle = `rgba(255,255,255,${glowAlpha})`;
    ctx.lineWidth = glowW;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.beginPath();
    ctx.moveTo(s[0].x - cameraX + SEGMENT/2, s[0].y - cameraY + SEGMENT/2);
    for(let i=1;i<s.length;i++) ctx.lineTo(s[i].x - cameraX + SEGMENT/2, s[i].y - cameraY + SEGMENT/2);
    ctx.stroke();
    ctx.restore();
  }

  ctx.strokeStyle = color || "white";
  ctx.lineWidth = BODY_WIDTH;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  ctx.beginPath();
  ctx.moveTo(s[0].x - cameraX + SEGMENT/2, s[0].y - cameraY + SEGMENT/2);
  for(let i=1;i<s.length;i++) ctx.lineTo(s[i].x - cameraX + SEGMENT/2, s[i].y - cameraY + SEGMENT/2);
  ctx.stroke();

  const head = s[0];
  ctx.fillStyle = color || "white";
  ctx.beginPath();
  ctx.arc(head.x - cameraX + SEGMENT/2, head.y - cameraY + SEGMENT/2, HEAD_RADIUS, 0, Math.PI*2);
  ctx.fill();

  let look = null;
  if(isMe){
    look = { x: dir?.x ?? 1, y: dir?.y ?? 0 };
  } else {
    const h = s[0], n = s[1];
    look = { x: h.x - n.x, y: h.y - n.y };
  }
  drawSnakeEyes(s, look);
}

/* =========================
   KEYBOARD
========================= */
function normKey(k){
  k = (k || "").toLowerCase();
  if(k === "—Ü") return "w";
  if(k === "—Ñ") return "a";
  if(k === "—ã") return "s";
  if(k === "–≤") return "d";
  return k;
}

function applyKeyboardVector(forceSend=false){
  if(!ws || dead) return;
  if(useMouse) return;

  const w = keysDown.has("w");
  const s = keysDown.has("s");
  const a = keysDown.has("a");
  const d = keysDown.has("d");

  let dx = 0, dy = 0;

  // X axis
  if(a && d){
    dx = lastAxisX;          // —Ñ–∏–∫—Å–∏—Ä—É–µ–º –ø–æ –ø–æ—Å–ª–µ–¥–Ω–µ–º—É –ù–ï–ø–æ–≤—Ç–æ—Ä–Ω–æ–º—É –Ω–∞–∂–∞—Ç–∏—é
  } else if(a){
    dx = -1;
  } else if(d){
    dx =  1;
  }

  // Y axis
  if(w && s){
    dy = lastAxisY;
  } else if(w){
    dy = -1;
  } else if(s){
    dy =  1;
  }

  if(dx === 0 && dy === 0) return;

  const len = Math.hypot(dx,dy) || 1;
  const nx = dx/len, ny = dy/len;

  wantDirUnit = {x:nx, y:ny};
  dir = {x: nx*CLIENT_SPEED, y: ny*CLIENT_SPEED};

  if(forceSend) sendDirection(nx, ny);
  else setDirection({x: dx, y: dy});
}

/* =========================
   DRAW LOOP
========================= */
function draw(ts){
  requestAnimationFrame(draw);
  if(canvas.style.display==="none") return;

  updateRafHz(ts);

  if(!isDying && !dead){
    if(!useMouse) applyKeyboardVector(true);
  }

  const newCap = getCapHz();
  if(newCap !== capHz) capHz = newCap;
  const stepMs = 1000 / capHz;

  if(draw._lastRafTs == null){
    draw._lastRafTs = ts;
    draw._acc = 0;
    draw._lastDeathTs = null;
  }

  let dt = ts - draw._lastRafTs;
  draw._lastRafTs = ts;

  if(dt > 120) dt = 120;
  draw._acc += dt;

  if(draw._acc < stepMs) return;
  draw._acc -= stepMs;

  const dtFrame = stepMs;
  const timeMs = ts;

  updateFpsOnRenderedFrame(timeMs);
  cleanupSnapshots();

  const gradient = ctx.createLinearGradient(0,0,canvas.width,canvas.height);
  gradient.addColorStop(0,"#1a1a1a");
  gradient.addColorStop(1,"#111");
  ctx.fillStyle=gradient;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const baseDelay = Math.min(120, Math.max(20, rtt * 0.35));
  const interpOthers = isDying ? 40 : Math.max(MIN_INTERP_MS, baseDelay);

  const renderPlayers = {};

  /* ===== ME: prediction ===== */
  if(players[playerId] && meBaseSnake && meBaseHead && mePredHead){
    if(meLastPredTs == null) meLastPredTs = timeMs;
    let dtMs = timeMs - meLastPredTs;
    meLastPredTs = timeMs;

    if(dtMs > 60) dtMs = 60;

    const spd = (meBaseBoost ? SPEED_BOOST_PX_S : SPEED_BASE_PX_S);
    const ds = spd * (dtMs / 1000);

    const ux = wantDirUnit?.x ?? 1;
    const uy = wantDirUnit?.y ?? 0;

    const turnAlpha = 1 - Math.exp(-dtMs / 65);

    predDirUnit.x = predDirUnit.x + (ux - predDirUnit.x) * turnAlpha;
    predDirUnit.y = predDirUnit.y + (uy - predDirUnit.y) * turnAlpha;
    const pl = Math.hypot(predDirUnit.x, predDirUnit.y) || 1;
    predDirUnit.x /= pl; predDirUnit.y /= pl;

    mePredHead.x += predDirUnit.x * ds;
    mePredHead.y += predDirUnit.y * ds;

    const dx = mePredHead.x - meBaseHead.x;
    const dy = mePredHead.y - meBaseHead.y;
    const maxLead = 90;
    const dd = Math.hypot(dx, dy);
    if(dd > maxLead){
      const k = maxLead / dd;
      mePredHead.x = meBaseHead.x + dx * k;
      mePredHead.y = meBaseHead.y + dy * k;
    }

    const offX = mePredHead.x - meBaseHead.x;
    const offY = mePredHead.y - meBaseHead.y;

    const n = meBaseSnake.length;
    const predSnake = new Array(n);

    const falloffLen = 10;
    for(let i=0;i<n;i++){
      const t = i / falloffLen;
      const w = (t >= 1) ? 0 : (1 - t) * (1 - t);
      const p = meBaseSnake[i];
      predSnake[i] = { x: p.x + offX * w, y: p.y + offY * w };
    }

    const alphaMe = 1 - Math.exp(-dtFrame / 32);
    const smoothMe = smoothSnake(playerId, predSnake, alphaMe);

    renderPlayers[playerId] = {
      snake: smoothMe,
      boost: meBaseBoost,
      color: players[playerId].color || "white"
    };
  }

  /* ===== OTHERS ===== */
  const renderTime = timeMs - interpOthers;
  for(const id in players){
    if(id === playerId) continue;
    const sp = sampleInterpSnake(id, renderTime);
    if(!sp) continue;

    const n = sp.snake?.length || 0;
    const tau = Math.min(180, 110 + n * 0.10);
    const alpha = 1 - Math.exp(-dtFrame / tau);

    const smooth = smoothSnake(id, sp.snake, alpha);
    renderPlayers[id] = { snake: smooth, boost: sp.boost, color: sp.color };
  }

  const meRender = renderPlayers[playerId]?.snake || null;
  const boostActive = !!renderPlayers[playerId]?.boost;

  hud.textContent =
`–†–µ–∂–∏–º: ${useMouse ? "–º—ã—à—å" : "WASD/–§–¶–´–í"} | –ò–≥—Ä–æ–∫–æ–≤: ${Object.keys(players).length} | FPS: ${fps}
Cap: ${Math.round(capHz)} (rAF‚âà${Math.round(rafMeter.hz)}) | RTT‚âà${Math.round(rtt)}ms | Shift: —É—Å–∫–æ—Ä–µ–Ω–∏–µ (${boostActive ? "–≤–∫–ª" : "–≤—ã–∫–ª"}) | M: —Ä–µ–∂–∏–º`;

  updateCamera(meRender);

  ctx.strokeStyle="rgba(255,255,255,0.05)";
  const gx0 = -((cameraX % GRID_STEP + GRID_STEP) % GRID_STEP);
  const gy0 = -((cameraY % GRID_STEP + GRID_STEP) % GRID_STEP);

  ctx.beginPath();
  for(let x=gx0; x<canvas.width; x+=GRID_STEP){ ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); }
  for(let y=gy0; y<canvas.height; y+=GRID_STEP){ ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); }
  ctx.stroke();

  let corpseGlowBudget = lowDetail ? 0 : 120;
  const foodStep = lowDetail ? 2 : 1;
  for(let i=0;i<foods.length;i+=foodStep){
    const f = foods[i];
    const mult = (typeof f.size === "number") ? f.size : 1;
    const baseR0 = (SEGMENT/4) * mult * Math.sqrt(SNAKE_SCALE);

    const x = f.x - cameraX + SEGMENT/2;
    const y = f.y - cameraY + SEGMENT/2;

    const isCorpse = (f.kind === "corpse");

    let alphaMul = 1.0;
    let scaleMul = 1.0;

    if(isCorpse){
      const key = foodKey(f);
      const born = foodBirth.get(key);
      if(typeof born === "number"){
        const t = (timeMs - born) / FOOD_POP_MS;
        const k = easeOutCubic(t);
        alphaMul = 0.10 + 0.90 * k;
        scaleMul = 0.72 + 0.28 * k;
      }
    }

    const baseR = baseR0 * scaleMul;

    ctx.save();
    if(isCorpse){
      ctx.globalAlpha = alphaMul;
      if(corpseGlowBudget > 0){
        corpseGlowBudget--;
        ctx.shadowColor = f.color || "white";
        ctx.shadowBlur = 18 * scaleMul;
      } else {
        ctx.shadowBlur = 0;
      }
    }

    ctx.fillStyle = f.color || (isCorpse ? "white" : "lime");
    ctx.beginPath();
    ctx.arc(x, y, baseR, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  for(const id in renderPlayers){
    const rp = renderPlayers[id];
    const isMe = (id === playerId);
    drawSnakeRibbon(rp.snake, rp.color, rp.boost, isMe, timeMs);
  }

  ctx.strokeStyle="red";
  ctx.lineWidth=4;
  ctx.strokeRect(-cameraX, -cameraY, WORLD_W, WORLD_H);

  if(isDying){
    const dtd = (draw._lastDeathTs == null) ? 16 : (timeMs - draw._lastDeathTs);
    draw._lastDeathTs = timeMs;

    if(!gotPostDeathState && deathPhase === "freeze"){
      postDeathWaitMs += dtd;
      if(postDeathWaitMs >= POST_DEATH_STATE_TIMEOUT_MS){
        gotPostDeathState = true;
      }
    }

    deathTimer += dtd;

    if(deathPhase === "freeze"){
      if(gotPostDeathState && deathTimer >= DEATH_FREEZE_MS){
        deathPhase = "fade";
        deathTimer = 0;
      }
    } else if(deathPhase === "fade"){
      deathFade = Math.min(1, deathTimer / DEATH_FADE_MS);
      ctx.fillStyle = `rgba(0,0,0,${deathFade})`;
      ctx.fillRect(0,0,canvas.width,canvas.height);

      if(deathFade >= 1){
        showMenuAfterDeath();
        resetDeathFlow();
      }
    }
  } else {
    draw._lastDeathTs = timeMs;
  }
}

/* =========================
   START / WS
========================= */
function resetMePrediction(){
  meBaseSnake = null;
  meBaseHead = null;
  mePredHead = null;
  meLastPredTs = null;
  meBaseBoost = false;
  predDirUnit = {x:1, y:0};
  lastTurnTs = 0;
}

function blendSnake(prev, next, k){
  if(!next || !next.length) return next;
  if(!prev || !prev.length) return next.map(p => ({x:p.x, y:p.y}));
  const n = Math.max(prev.length, next.length);
  const out = new Array(n);
  for(let i=0;i<n;i++){
    const a = prev[i] || prev[prev.length-1];
    const b = next[i] || next[next.length-1];
    out[i] = { x: a.x + (b.x - a.x)*k, y: a.y + (b.y - a.y)*k };
  }
  return out;
}

function startGame(){
  resetDeathFlow();
  resetMePrediction();

  dead = false;
  dir = {x:1,y:0};
  wantDirUnit = {x:1,y:0};
  players = {};
  foods = [];
  keysDown.clear();
  serverBoosting = false;
  lastSent = 0;
  lastDirSent = {x:1,y:0};

  // axis default
  lastAxisX = 1;
  lastAxisY = -1;

  camHX = null; camHY = null;
  for(const id in snapshots) delete snapshots[id];
  for(const id in renderCache) delete renderCache[id];
  foodBirth.clear();

  menu.style.display="none";
  canvas.style.display="block";
  hud.style.display="block";

  canvas.width=innerWidth;
  canvas.height=innerHeight;
  canvas.focus();

  playerId="player"+Math.floor(Math.random()*9999);
  ws=new WebSocket(wsUrl(`/ws/${ROOM_ID}/${playerId}`));

  ws.onopen = () => {
    startRttPing();
    startInputHeartbeat();
  };

  ws.onmessage = (e) => {
    const data = JSON.parse(e.data);

    if (data.type === "pong") {
      const now = performance.now();
      const sample = Math.max(0, now - (data.t || now));
      rtt = rtt*0.8 + sample*0.2;
      return;
    }

    if (data.type === "death") {
      dead = true;
      isDying = true;
      deathPhase = "freeze";
      deathTimer = 0;
      postDeathWaitMs = 0;
      gotPostDeathState = false;
      sendBoost(false);
      resetMePrediction();
      return;
    }

    if (data.players) players = data.players;

    if (Array.isArray(data.foods)) {
      foods = data.foods;
      markFoodBirths(foods, performance.now());
    }

    if (isDying && !gotPostDeathState && data.players) {
      gotPostDeathState = true;
      deathTimer = 0;
    }

    for (const id in players) pushSnapshot(id, players[id]);

    const me = players[playerId];
    if(me && me.snake && me.snake.length){
      const fresh = me.snake.map(p => ({x:p.x, y:p.y}));
      meBaseSnake = blendSnake(meBaseSnake, fresh, 0.35);

      meBaseHead = {x: meBaseSnake[0].x, y: meBaseSnake[0].y};
      meBaseBoost = !!me.boost;

      if(!mePredHead){
        mePredHead = {x: meBaseHead.x, y: meBaseHead.y};
        predDirUnit = {x: wantDirUnit.x, y: wantDirUnit.y};
      } else {
        const k = 0.35;
        mePredHead.x = mePredHead.x + (meBaseHead.x - mePredHead.x) * k;
        mePredHead.y = mePredHead.y + (meBaseHead.y - mePredHead.y) * k;
      }
    }
  };

  ws.onclose=()=>{
    if(rttTimer){ clearInterval(rttTimer); rttTimer = null; }
    if(inputTimer){ clearInterval(inputTimer); inputTimer = null; }
    if(!isDying) setTimeout(()=>showMenuAfterDeath(), 150);
  };
}

/* =========================
   INPUT
========================= */
canvas.addEventListener("mousemove", e=>{
  if(isDying) return;
  if(!useMouse) return;
  const me = players[playerId];
  if(!me || dead || !me.snake || !me.snake[0]) return;
  const head = me.snake[0];
  const mx = e.clientX + cameraX - head.x;
  const my = e.clientY + cameraY - head.y;
  setDirection({x: mx, y: my});
});

document.addEventListener("keydown", e=>{
  if(isDying) return;
  if(e.key === "m" || e.key === "M"){
    useMouse = !useMouse;
    keysDown.clear();
  }
});

function updateAxisOnPress(k){
  if(k === "a") lastAxisX = -1;
  if(k === "d") lastAxisX =  1;
  if(k === "w") lastAxisY = -1;
  if(k === "s") lastAxisY =  1;
}

document.addEventListener("keydown", e=>{
  if(isDying) return;
  if(dead) return;

  const k = normKey(e.key);

  if(k === "shift"){
    sendBoost(true);
    e.preventDefault?.();
    return;
  }

  if(k === "w" || k === "a" || k === "s" || k === "d"){
    // ===== FIX: ignore key-repeat completely =====
    if(keysDown.has(k)){
      e.preventDefault?.();
      return;
    }

    keysDown.add(k);
    updateAxisOnPress(k);

    e.preventDefault?.();
  }
});

document.addEventListener("keyup", e=>{
  const k = normKey(e.key);

  if(k === "shift"){
    sendBoost(false);
    e.preventDefault?.();
    return;
  }

  if(k === "w" || k === "a" || k === "s" || k === "d"){
    keysDown.delete(k);
    e.preventDefault?.();
  }
});

window.addEventListener("blur", () => sendBoost(false));
document.addEventListener("visibilitychange", () => { if(document.hidden) sendBoost(false); });

playBtn.onclick=startGame;

window.addEventListener("resize",()=>{
  canvas.width=innerWidth;
  canvas.height=innerHeight;
});

requestAnimationFrame(draw);
</script>
</body>
</html>
