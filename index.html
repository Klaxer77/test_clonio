<!-- index.html (FULL) ‚Äî FIX: reduce freezes on long snakes (Float32 snaps + less GC), keep no-jerk on eat -->
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Snake Smooth Multiplayer</title>
  <style>
    html,body{
      margin:0;padding:0;
      overflow:hidden;
      font-family:Arial,sans-serif;
      background: linear-gradient(135deg, #1a1a1a 0%, #111 100%);
      color:white;
      height:100%;
    }
    body{ position:fixed; inset:0; }
    canvas{ display:block; outline:none; touch-action:none; }
    #menu{
      position:fixed;inset:0;
      display:flex;align-items:center;justify-content:center;flex-direction:column;
      background: rgba(0,0,0,0.82);
      gap:14px;text-align:center;padding:24px;box-sizing:border-box;
      z-index:30;
    }
    button{font-size:24px;padding:15px 40px;cursor:pointer;border:none;background:lime;color:black;border-radius:10px;}
    button:hover{background:#7CFF7C;}
    .hud{
      position:fixed;left:12px;top:10px;z-index:25;
      font-size:14px;opacity:.85;user-select:none;pointer-events:none;
      text-shadow:0 1px 2px rgba(0,0,0,.6);
      line-height:1.35;white-space:pre;
    }
    #touchUI{
      position:fixed; inset:0; z-index:20;
      display:none;
      pointer-events:none;
      touch-action:none;
    }
    #joyWrap{
      position:absolute; left:16px; bottom:18px;
      width:120px; height:120px;
      pointer-events:auto; touch-action:none;
    }
    #joyBase{
      width:100%; height:100%;
      border-radius:999px;
      background:rgba(255,255,255,0.10);
      border:1px solid rgba(255,255,255,0.18);
      backdrop-filter: blur(4px);
      position:relative;
    }
    #joyKnob{
      position:absolute; left:50%; top:50%;
      width:48px; height:48px;
      margin-left:-24px; margin-top:-24px;
      border-radius:999px;
      background:rgba(255,255,255,0.22);
      border:1px solid rgba(255,255,255,0.25);
      box-shadow:0 8px 18px rgba(0,0,0,.35);
      transform:translate(0,0);
      will-change:transform;
    }
    #btnWrap{
      position:absolute; right:18px; bottom:28px;
      display:flex; flex-direction:column; gap:12px;
      pointer-events:auto; touch-action:none;
    }
    #boostBtn,.boostBtn{
      -webkit-user-select:none; user-select:none;
      -webkit-touch-callout:none;
      -webkit-tap-highlight-color:transparent;
      outline:none; -webkit-appearance:none; appearance:none;
      caret-color:transparent;
    }
    #boostBtn:focus,#boostBtn:focus-visible{ outline:none; }
    .boostBtn{
      width:72px; height:72px; border-radius:999px;
      display:flex; align-items:center; justify-content:center;
      font-size:32px; font-weight:700;
      background: radial-gradient(circle at 30% 30%, #ffe066, #f5c400);
      color:#111;
      border:1px solid rgba(255,255,255,0.25);
      box-shadow: 0 10px 22px rgba(0,0,0,.35), inset 0 2px 4px rgba(255,255,255,.35);
      -webkit-tap-highlight-color: transparent;
    }
    .boostBtn .icon{ display:block; line-height:1; pointer-events:none; user-select:none; }
    .boostBtn:active{
      transform: scale(0.96);
      box-shadow: 0 6px 14px rgba(0,0,0,.35), inset 0 1px 3px rgba(255,255,255,.35);
    }
    @media (pointer:coarse){
      .hud{top:8px;left:10px;font-size:12px;opacity:.78;}
    }
  </style>
</head>
<body>
  <div id="menu">
    <h1>üêç Snake</h1>
    <button id="playBtn">–ò–≥—Ä–∞—Ç—å</button>
  </div>

  <div id="hud" class="hud" style="display:none"></div>
  <canvas id="game" tabindex="0"></canvas>

  <div id="touchUI" aria-hidden="true">
    <div id="joyWrap">
      <div id="joyBase"><div id="joyKnob"></div></div>
    </div>
    <div id="btnWrap">
      <button id="boostBtn" class="boostBtn" aria-label="–£—Å–∫–æ—Ä–µ–Ω–∏–µ">
        <span class="icon" aria-hidden="true">‚ö°</span>
      </button>
    </div>
  </div>

<script>
const WORLD_W = 3000, WORLD_H = 3000;
const SEGMENT = 30;
const ROOM_ID = "room1";

const CLIENT_SPEED = 4;
const SEG_DIST = SEGMENT * 0.85;

let ws=null, playerId=null, foods=[], cameraX=0, cameraY=0;
let dir = {x:1, y:0}, dead=false;

let useMouse = false;
let useTouch = false;

let serverBoosting = false;
const keysDown = new Set();
let lastAxisX = 1;
let lastAxisY = -1;

const menu=document.getElementById("menu"),
      playBtn=document.getElementById("playBtn"),
      canvas=document.getElementById("game"),
      hud=document.getElementById("hud"),
      ctx=canvas.getContext("2d");

const touchUI = document.getElementById("touchUI");
const joyWrap = document.getElementById("joyWrap");
const joyKnob = document.getElementById("joyKnob");
const boostBtn = document.getElementById("boostBtn");

const isTouchDevice =
  (window.matchMedia && window.matchMedia("(pointer:coarse)").matches) ||
  ("ontouchstart" in window) ||
  (navigator.maxTouchPoints > 0);

function wsUrl(path){
  const proto = (location.protocol === "https:") ? "wss" : "ws";
  return `${proto}://${location.host}${path}`;
}

function clamp01(v){ return Math.max(-1, Math.min(1, v)); }
function lerp(a,b,t){ return a + (b-a)*t; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function normAngle(a){
  while(a > Math.PI) a -= Math.PI*2;
  while(a < -Math.PI) a += Math.PI*2;
  return a;
}

/* SCALE */
const DESKTOP_SNAKE_SCALE = 1.35;
const MOBILE_SNAKE_SCALE  = 0.60;
let SNAKE_SCALE = DESKTOP_SNAKE_SCALE;
let GRID_STEP = Math.round(SEGMENT * 2.4);
const MOBILE_VIEW_ZOOM = 0.82;
let VIEW_ZOOM = 1;

/* FPS */
let lastFpsTs = performance.now();
let frames = 0;
let lowDetail = false;
let fps = 60;

function updateFpsOnRenderedFrame(timeMs){
  frames++;
  const dt = timeMs - lastFpsTs;
  if(dt >= 500){
    fps = Math.round((frames * 1000) / dt);
    frames = 0;
    lastFpsTs = timeMs;
    lowDetail = fps < 45;
    GRID_STEP = Math.round(SEGMENT * (lowDetail ? 3.2 : 2.4));
  }
}

/* RTT */
let rtt = 60;
let rttTimer = null;
function startRttPing(){
  if(rttTimer) clearInterval(rttTimer);
  rttTimer = setInterval(()=>{
    if(!ws || ws.readyState !== 1) return;
    ws.send(JSON.stringify({type:"ping", t: performance.now()}));
  }, 800);
}

/* RAF cap */
const TARGET_CAP = 75;
const rafMeter = { lastTs: null, samples: [], maxSamples: 90, hz: 60 };
function updateRafHz(ts){
  if(rafMeter.lastTs == null){ rafMeter.lastTs = ts; return; }
  const dt = ts - rafMeter.lastTs;
  rafMeter.lastTs = ts;
  if(dt <= 0) return;
  const instHz = 1000 / dt;
  if(instHz < 10 || instHz > 400) return;
  rafMeter.samples.push(instHz);
  if(rafMeter.samples.length > rafMeter.maxSamples) rafMeter.samples.shift();
  const a = rafMeter.samples.slice().sort((x,y)=>x-y);
  const mid = a.length >> 1;
  const med = a.length ? (a.length % 2 ? a[mid] : (a[mid-1]+a[mid])/2) : 60;
  const snap = (v) => {
    const presets = [50,60,75,90,100,120,144,165,180,240];
    let best=v, bestD=1e9;
    for(const p of presets){
      const d = Math.abs(v-p);
      if(d<bestD){ bestD=d; best=p; }
    }
    return (bestD <= 3.0) ? best : v;
  };
  rafMeter.hz = snap(med);
}
let capHz = 60;
function getCapHz(){ return Math.min(rafMeter.hz || 60, TARGET_CAP); }

/* CANVAS SIZE */
let VIEW_W = innerWidth, VIEW_H = innerHeight;

function fitCanvas(){
  const vv = window.visualViewport;
  const w = vv ? Math.round(vv.width)  : innerWidth;
  const h = vv ? Math.round(vv.height) : innerHeight;
  VIEW_W = w; VIEW_H = h;
  if(isTouchDevice){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.style.width = w + "px";
    canvas.style.height = h + "px";
    canvas.width  = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.imageSmoothingEnabled = true;
  } else {
    canvas.width = w;
    canvas.height = h;
    ctx.setTransform(1,0,0,1,0,0);
  }
}
window.addEventListener("resize", fitCanvas);
window.visualViewport?.addEventListener("resize", fitCanvas);
window.visualViewport?.addEventListener("scroll", fitCanvas);

/* RENDER HELPERS */
function bodyWidth(){ return SEGMENT * 0.95 * SNAKE_SCALE; }
function headRadius(){ return bodyWidth() * 0.50; }
function eyeWhiteR(){ return headRadius() * 0.38; }
function eyePupilR(){ return eyeWhiteR() * 0.45; }
function pupilShift(){ return eyeWhiteR() * 0.35; }

/* CAMERA */
let camHX = null, camHY = null;
const CAM_SMOOTH = 0.18;
function updateCamera(renderMeSnake){
  if(!renderMeSnake || renderMeSnake.length === 0) return;
  const h = renderMeSnake[0];
  if(camHX === null){ camHX = h.x; camHY = h.y; }
  camHX = camHX + (h.x - camHX) * CAM_SMOOTH;
  camHY = camHY + (h.y - camHY) * CAM_SMOOTH;
  cameraX = camHX - (VIEW_W / (2 * VIEW_ZOOM));
  cameraY = camHY - (VIEW_H / (2 * VIEW_ZOOM));
}
function sx(wx){ return (wx - cameraX) * VIEW_ZOOM + SEGMENT/2; }
function sy(wy){ return (wy - cameraY) * VIEW_ZOOM + SEGMENT/2; }

/* EYES + RIBBON */
function drawSnakeEyes(s, look){
  if(!s || s.length < 2) return;
  const h = s[0], n = s[1];
  let fx = h.x - n.x, fy = h.y - n.y;
  const fl = Math.hypot(fx, fy) || 1;
  fx/=fl; fy/=fl;
  const lx = -fy, ly = fx;
  const cx = sx(h.x), cy = sy(h.y);
  const HR  = headRadius() * VIEW_ZOOM;
  const EWR = eyeWhiteR() * VIEW_ZOOM;
  const EPR = eyePupilR() * VIEW_ZOOM;
  const PS  = pupilShift() * VIEW_ZOOM;
  const side = HR * 0.55, fwd = HR * 0.20;
  const ex1 = cx + lx*side + fx*fwd;
  const ey1 = cy + ly*side + fy*fwd;
  const ex2 = cx - lx*side + fx*fwd;
  const ey2 = cy - ly*side + fy*fwd;

  let dx = look?.x ?? fx, dy = look?.y ?? fy;
  const dl = Math.hypot(dx, dy) || 1; dx/=dl; dy/=dl;
  const lookF = clamp01(dx*fx + dy*fy);
  const lookL = clamp01(dx*lx + dy*ly);
  const pxShiftX = fx*(lookF*PS) + lx*(lookL*PS);
  const pxShiftY = fy*(lookF*PS) + ly*(lookL*PS);

  ctx.save();
  ctx.fillStyle = "white";
  ctx.beginPath(); ctx.arc(ex1, ey1, EWR, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(ex2, ey2, EWR, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = "black";
  ctx.beginPath(); ctx.arc(ex1 + pxShiftX, ey1 + pxShiftY, EPR, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(ex2 + pxShiftX, ey2 + pxShiftY, EPR, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

function decimate(points, step){
  if(step <= 1) return points;
  const out = [];
  for(let i=0;i<points.length;i+=step) out.push(points[i]);
  if(points.length && out[out.length-1] !== points[points.length-1]) out.push(points[points.length-1]);
  return out;
}

function drawSnakeRibbon(renderSnake, color, boost, isMe, timeMs){
  const base = renderSnake || [];
  if(base.length < 2) return;

  // FIX: for very long "me" snake reduce points a bit (cheap win)
  let s;
  if(isMe){
    const n = base.length|0;
    const step = (n > 360) ? 3 : (n > 220 ? 2 : 1);
    s = (step === 1) ? base : decimate(base, step);
  } else {
    s = decimate(base, lowDetail ? 3 : 2);
  }

  const BW = bodyWidth() * VIEW_ZOOM;
  const HR = headRadius() * VIEW_ZOOM;

  if(boost){
    const pulse1 = 0.5 + 0.5*Math.sin(timeMs * 0.022);
    const pulse2 = 0.5 + 0.5*Math.sin(timeMs * 0.017 + 1.2);
    const glowAlpha = lowDetail ? 0.10 : (0.16 + 0.10*pulse1);
    const glowW = BW * ((isMe ? 2.10 : 1.95) + 0.45*pulse2);
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.strokeStyle = `rgba(255,255,255,${glowAlpha})`;
    ctx.lineWidth = glowW;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.beginPath();
    ctx.moveTo(sx(s[0].x), sy(s[0].y));
    for(let i=1;i<s.length;i++) ctx.lineTo(sx(s[i].x), sy(s[i].y));
    ctx.stroke();
    ctx.restore();
  }

  ctx.strokeStyle = color || "white";
  ctx.lineWidth = BW;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  ctx.beginPath();
  ctx.moveTo(sx(s[0].x), sy(s[0].y));
  for(let i=1;i<s.length;i++) ctx.lineTo(sx(s[i].x), sy(s[i].y));
  ctx.stroke();

  const head = s[0];
  ctx.fillStyle = color || "white";
  ctx.beginPath();
  ctx.arc(sx(head.x), sy(head.y), HR, 0, Math.PI*2);
  ctx.fill();

  let look = null;
  if(isMe){
    look = { x: dir?.x ?? 1, y: dir?.y ?? 0 };
  } else {
    const hh = s[0], nn = s[1];
    look = { x: hh.x - nn.x, y: hh.y - nn.y };
  }
  drawSnakeEyes(s, look);
}

/* ====== remote players ====== */
const remote = {};
const REMOTE_PATH_MAX = 1400;

function buildSnakeFromPath(path, lengthSegments){
  const n = Math.max(1, lengthSegments|0);
  if(!path || path.length === 0) return [{x:0,y:0}];

  const out = [];
  out.push({x: path[0].x, y: path[0].y});
  if(n === 1) return out;

  let want = 0;
  let acc = 0;

  for(let i=0;i<path.length-1 && out.length < n;i++){
    const a = path[i];
    const b = path[i+1];
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const segLen = Math.hypot(dx, dy);
    if(segLen < 1e-6) continue;

    while(out.length < n && (acc + segLen) >= (want + SEG_DIST)){
      want += SEG_DIST;
      const t = (want - acc) / segLen;
      out.push({ x: a.x + dx*t, y: a.y + dy*t });
    }
    acc += segLen;
  }

  const last = out[out.length-1];
  while(out.length < n) out.push({x:last.x, y:last.y});
  return out;
}

function snakePointsFromFlatBody(bodyFlat){
  const out = [];
  if(!Array.isArray(bodyFlat)) return out;
  for(let i=0;i<bodyFlat.length;i+=2){
    out.push({ x: +bodyFlat[i], y: +bodyFlat[i+1] });
  }
  return out;
}

/* ===== LENGTH-SAFE HELPERS (main fix) ===== */
function padToLen(snake, n){
  if(!snake) return snake;
  const m = snake.length|0;
  if(m >= n) return snake;
  const out = snake.slice();
  const last = out.length ? out[out.length-1] : {x:0,y:0};
  while(out.length < n) out.push({x:last.x, y:last.y});
  return out;
}

/* ===== render-in-the-past interpolation ===== */
const INTERP_DELAY_MS = 160;
const SNAP_MAX = 12;

/* ==== FIX: snaps stored as Float32Array (less GC on long snakes) ==== */
function snakeToFlatF32(snake){
  const n = snake.length|0;
  const out = new Float32Array(n * 2);
  for(let i=0;i<n;i++){
    out[i*2]   = snake[i].x;
    out[i*2+1] = snake[i].y;
  }
  return out;
}
function padFlatToLen(flat, wantFloats){
  if(!flat) return flat;
  const m = flat.length|0;
  if(m >= wantFloats) return flat;
  const out = new Float32Array(wantFloats);
  out.set(flat);
  const lx = m >= 2 ? flat[m-2] : 0;
  const ly = m >= 2 ? flat[m-1] : 0;
  for(let i=m;i<wantFloats;i+=2){
    out[i] = lx; out[i+1] = ly;
  }
  return out;
}
function flatF32ToPoints(flat){
  const n = (flat.length/2)|0;
  const out = new Array(n);
  for(let i=0;i<n;i++){
    out[i] = { x: flat[i*2], y: flat[i*2+1] };
  }
  return out;
}

function pushSnap(r, snake, timeMs){
  if(!snake || snake.length < 2) return;
  if(!r.snaps) r.snaps = [];
  r.snaps.push({
    t: timeMs,
    flat: snakeToFlatF32(snake),
    boost: !!r.boost,
    color: r.color || "white",
  });
  if(r.snaps.length > SNAP_MAX) r.snaps.shift();
}

function interpSnakeFromSnaps(snaps, renderTime){
  if(!snaps || snaps.length === 0) return null;
  if(snaps.length === 1) return flatF32ToPoints(snaps[0].flat);

  if(renderTime <= snaps[0].t) return flatF32ToPoints(snaps[0].flat);
  const last = snaps[snaps.length - 1];
  if(renderTime >= last.t) return flatF32ToPoints(last.flat);

  let i = snaps.length - 2;
  while(i >= 0 && snaps[i].t > renderTime) i--;
  i = Math.max(0, i);

  const a = snaps[i];
  const b = snaps[i + 1] || a;
  const span = Math.max(1, b.t - a.t);
  const k = Math.max(0, Math.min(1, (renderTime - a.t) / span));

  let fa = a.flat, fb = b.flat;
  if(!fa || !fb) return null;

  const n = Math.max(fa.length, fb.length);
  fa = padFlatToLen(fa, n);
  fb = padFlatToLen(fb, n);

  const out = new Float32Array(n);
  for(let j=0;j<n;j++){
    out[j] = lerp(fa[j], fb[j], k);
  }
  return flatF32ToPoints(out);
}

/* ===== length-safe smoothing (main fix) ===== */
const renderCache = {};
function smoothSnake(id, targetSnake, alpha){
  if(!targetSnake || targetSnake.length === 0) return targetSnake;

  let prev = renderCache[id];

  if(!prev || prev.length === 0){
    renderCache[id] = targetSnake.map(p => ({x:p.x, y:p.y}));
    return renderCache[id];
  }

  const n = Math.max(prev.length, targetSnake.length);
  prev = padToLen(prev, n);
  const tgt = padToLen(targetSnake, n);

  const out = new Array(n);
  for(let i=0;i<n;i++){
    const tp = tgt[i];
    const pp = prev[i] || tp;
    out[i] = { x: lerp(pp.x, tp.x, alpha), y: lerp(pp.y, tp.y, alpha) };
  }
  renderCache[id] = out;
  return out;
}

/* INPUT + STEERING */
function normKey(k){
  k = (k || "").toLowerCase();
  if(k === "—Ü") return "w";
  if(k === "—Ñ") return "a";
  if(k === "—ã") return "s";
  if(k === "–≤") return "d";
  return k;
}

let lastSent = 0;
let lastDirSent = {x:1, y:0};
let wantDirUnit = {x:1, y:0};

const SEND_EPS2 = 0.00025;
const SEND_MIN_MS = 20;
const SEND_IDLE_MS = 90;

function sendDirection(nx, ny){
  if(!ws) return;
  if(dead) return;
  if(ws.readyState !== 1) return;

  const now = performance.now();
  const dx = nx - lastDirSent.x;
  const dy = ny - lastDirSent.y;
  const changed = (dx*dx + dy*dy) > SEND_EPS2;

  if(!changed && (now - lastSent) < SEND_IDLE_MS) return;
  if((now - lastSent) < SEND_MIN_MS) return;

  lastSent = now;
  lastDirSent = {x:nx, y:ny};
  ws.send(JSON.stringify({direction: {x: nx, y: ny}}));
}

function setDirUnit(nx, ny){
  const l = Math.hypot(nx, ny) || 1;
  nx /= l; ny /= l;
  wantDirUnit = {x:nx, y:ny};
  dir = {x: nx*CLIENT_SPEED, y: ny*CLIENT_SPEED};
  sendDirection(nx, ny);
}

let heading = 0;
let angVel = 0;

const TURN_BASE = 3.6;
const TURN_FAST = 5.2;
const TURN_SLOW = 2.2;
const TURN_TAU_MS = 35;
const TURN_STOP_TAU_MS = 55;

const MOUSE_GAIN = 9.0;
const MOUSE_TAU_MS = 22;
const MOUSE_DEADZONE_RAD = 0.010;

const TOUCH_GAIN = 5.2;
const TOUCH_TAU_MS = 34;

let mouseTargetHeading = null;
let touchTargetHeading = null;

function initHeadingFromVector(v){
  heading = Math.atan2(v.y, v.x);
  angVel = 0;
  mouseTargetHeading = heading;
  touchTargetHeading = heading;
}

function applySteeringKeyboard(dtMs){
  const left  = keysDown.has("a");
  const right = keysDown.has("d");
  const fast  = keysDown.has("w");
  const slow  = keysDown.has("s");

  let turn = 0;
  if(left && !right) turn = -1;
  else if(right && !left) turn = 1;
  else if(left && right) turn = lastAxisX;

  let turnRate = TURN_BASE;
  if(fast && !slow) turnRate = TURN_FAST;
  if(slow && !fast) turnRate = TURN_SLOW;

  const targetAngVel = turn * turnRate;
  const tau = (turn !== 0) ? TURN_TAU_MS : TURN_STOP_TAU_MS;
  const k = 1 - Math.exp(-dtMs / tau);
  angVel = angVel + (targetAngVel - angVel) * k;

  heading += angVel * (dtMs / 1000);
  setDirUnit(Math.cos(heading), Math.sin(heading));
}

function applySteeringPointer(dtMs){
  const target = useTouch ? touchTargetHeading : mouseTargetHeading;
  if(target == null) return;

  const err = normAngle(target - heading);
  const maxVel = TURN_FAST;

  const gain = useTouch ? TOUCH_GAIN : MOUSE_GAIN;
  const tau  = useTouch ? TOUCH_TAU_MS : MOUSE_TAU_MS;

  let targetAngVel = 0;
  if(Math.abs(err) > MOUSE_DEADZONE_RAD){
    targetAngVel = clamp(err * gain, -maxVel, +maxVel);
  }

  const k = 1 - Math.exp(-dtMs / tau);
  angVel = angVel + (targetAngVel - angVel) * k;
  heading += angVel * (dtMs / 1000);
  setDirUnit(Math.cos(heading), Math.sin(heading));
}

function applySteering(dtMs){
  if(!ws || ws.readyState !== 1) return;
  if(dead) return;
  if(useTouch) applySteeringPointer(dtMs);
  else if(useMouse) applySteeringPointer(dtMs);
  else applySteeringKeyboard(dtMs);
}

let inputTimer = null;
let lastInputTs = null;
function startInputHeartbeat(){
  if(inputTimer) clearInterval(inputTimer);
  lastInputTs = performance.now();
  inputTimer = setInterval(()=>{
    if(!ws || ws.readyState !== 1) return;
    if(dead) return;
    const now = performance.now();
    let dt = now - lastInputTs;
    lastInputTs = now;
    if(dt < 1) dt = 1;
    if(dt > 40) dt = 40;
    applySteering(dt);
  }, 16);
}

function sendBoost(state){
  if(!ws) return;
  if(ws.readyState !== 1) return;
  if(state === serverBoosting) return;
  serverBoosting = state;
  ws.send(JSON.stringify({boost: state}));
}

/* FOOD pop */
const foodBirth = new Map();
const FOOD_POP_MS = 380;

function foodKey(f){
  const x = (f && typeof f.x === "number") ? f.x : 0;
  const y = (f && typeof f.y === "number") ? f.y : 0;
  const k = f?.kind || "";
  const c = f?.color || "";
  const s = (typeof f?.size === "number") ? f.size : 1;
  return `${x}|${y}|${k}|${c}|${s}`;
}
function markFoodBirths(newFoods, timeMs){
  for(const f of (newFoods || [])){
    if(f?.kind !== "corpse") continue;
    const key = foodKey(f);
    if(!foodBirth.has(key)) foodBirth.set(key, timeMs);
  }
  if(!markFoodBirths._nextClean) markFoodBirths._nextClean = timeMs + 2000;
  if(timeMs < markFoodBirths._nextClean) return;
  markFoodBirths._nextClean = timeMs + 2000;
  const cutoff = timeMs - 8000;
  for(const [k, born] of foodBirth.entries()){
    if(born < cutoff) foodBirth.delete(k);
  }
}
function easeOutCubic(t){
  t = Math.max(0, Math.min(1, t));
  return 1 - Math.pow(1 - t, 3);
}

/* DRAW LOOP */
function draw(ts){
  requestAnimationFrame(draw);
  if(canvas.style.display==="none") return;

  updateRafHz(ts);

  const newCap = getCapHz();
  if(newCap !== capHz) capHz = newCap;
  const stepMs = 1000 / capHz;

  if(draw._lastRafTs == null){
    draw._lastRafTs = ts;
    draw._acc = 0;
  }
  let dt = ts - draw._lastRafTs;
  draw._lastRafTs = ts;
  if(dt > 120) dt = 120;
  draw._acc += dt;
  if(draw._acc < stepMs) return;
  draw._acc -= stepMs;

  const dtFrame = stepMs;
  const timeMs = ts;

  updateFpsOnRenderedFrame(timeMs);

  const gradient = ctx.createLinearGradient(0,0,VIEW_W,VIEW_H);
  gradient.addColorStop(0,"#1a1a1a");
  gradient.addColorStop(1,"#111");
  ctx.fillStyle=gradient;
  ctx.fillRect(0,0,VIEW_W,VIEW_H);

  const renderPlayers = {};
  const renderTime = timeMs - INTERP_DELAY_MS;

  const meR = remote[playerId];
  if(meR && meR.snaps && meR.snaps.length){
    const meI = interpSnakeFromSnaps(meR.snaps, renderTime);
    if(meI && meI.length){
      const alphaMe = 1 - Math.exp(-dtFrame / 35);
      const smoothMe = smoothSnake(playerId, meI, alphaMe);
      renderPlayers[playerId] = { snake: smoothMe, boost: !!meR.boost, color: meR.color || "white" };
    }
  }

  for(const id in remote){
    if(id === playerId) continue;
    const r = remote[id];
    if(!r || !r.snaps || !r.snaps.length) continue;

    const sI = interpSnakeFromSnaps(r.snaps, renderTime);
    if(!sI || sI.length < 2) continue;

    const n = sI.length;
    const tau = Math.min(260, 180 + n * 0.18);
    const alpha = 1 - Math.exp(-dtFrame / tau);
    const smooth = smoothSnake(id, sI, alpha);

    renderPlayers[id] = { snake: smooth, boost: !!r.boost, color: r.color || "white" };
  }

  const meRender = renderPlayers[playerId]?.snake || null;
  const boostActive = !!renderPlayers[playerId]?.boost;

  hud.textContent =
`–†–µ–∂–∏–º: ${useTouch ? "–º–æ–± (–¥–∂–æ–π—Å—Ç–∏–∫)" : (useMouse ? "–º—ã—à—å" : "–∫–ª–∞–≤–∞ (A/D —Ä—É–ª–∏—Ç, W –±—ã—Å—Ç—Ä–µ–µ, S —Ç–æ—á–Ω–µ–µ)")}
FPS: ${fps} | Cap: ${Math.round(capHz)} | RTT‚âà${Math.round(rtt)}ms | –£—Å–∫–æ—Ä–µ–Ω–∏–µ: ${boostActive ? "–≤–∫–ª" : "–≤—ã–∫–ª"} | M/–¨: —Ä–µ–∂–∏–º (–ü–ö)`;

  updateCamera(meRender);

  // grid
  ctx.strokeStyle="rgba(255,255,255,0.05)";
  const step = GRID_STEP;
  const left = cameraX;
  const top  = cameraY;
  const right = cameraX + (VIEW_W / VIEW_ZOOM);
  const bottom= cameraY + (VIEW_H / VIEW_ZOOM);
  const x0 = Math.floor(left / step) * step;
  const y0 = Math.floor(top  / step) * step;

  ctx.beginPath();
  for(let x=x0; x<=right; x+=step){
    const X = sx(x);
    ctx.moveTo(X, 0);
    ctx.lineTo(X, VIEW_H);
  }
  for(let y=y0; y<=bottom; y+=step){
    const Y = sy(y);
    ctx.moveTo(0, Y);
    ctx.lineTo(VIEW_W, Y);
  }
  ctx.stroke();

  // food
  let corpseGlowBudget = lowDetail ? 0 : 120;
  const foodStep = lowDetail ? 2 : 1;
  for(let i=0;i<foods.length;i+=foodStep){
    const f = foods[i];
    const mult = (typeof f.size === "number") ? f.size : 1;
    const baseR0 = (SEGMENT/4) * mult * Math.sqrt(SNAKE_SCALE);
    const x = sx(f.x);
    const y = sy(f.y);
    const isCorpse = (f.kind === "corpse");
    let alphaMul = 1.0;
    let scaleMul = 1.0;

    if(isCorpse){
      const key = foodKey(f);
      const born = foodBirth.get(key);
      if(typeof born === "number"){
        const t = (timeMs - born) / FOOD_POP_MS;
        const k = easeOutCubic(t);
        alphaMul = 0.10 + 0.90 * k;
        scaleMul = 0.72 + 0.28 * k;
      }
    }

    const baseR = baseR0 * scaleMul * VIEW_ZOOM;

    ctx.save();
    if(isCorpse){
      ctx.globalAlpha = alphaMul;
      if(corpseGlowBudget > 0){
        corpseGlowBudget--;
        ctx.shadowColor = f.color || "white";
        ctx.shadowBlur = 18 * scaleMul;
      } else {
        ctx.shadowBlur = 0;
      }
    }

    ctx.fillStyle = f.color || (isCorpse ? "white" : "lime");
    ctx.beginPath();
    ctx.arc(x, y, baseR, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  for(const id in renderPlayers){
    const rp = renderPlayers[id];
    drawSnakeRibbon(rp.snake, rp.color, rp.boost, id === playerId, timeMs);
  }

  ctx.strokeStyle="red";
  ctx.lineWidth=4;
  ctx.strokeRect(
    sx(0) - SEGMENT/2,
    sy(0) - SEGMENT/2,
    WORLD_W * VIEW_ZOOM,
    WORLD_H * VIEW_ZOOM
  );
}

/* START / WS */
const td = new TextDecoder();

function startGame(){
  dead = false;

  SNAKE_SCALE = isTouchDevice ? MOBILE_SNAKE_SCALE : DESKTOP_SNAKE_SCALE;
  dir = {x:1,y:0};
  initHeadingFromVector({x:1,y:0});

  foods = [];
  for(const k in remote) delete remote[k];
  for(const k in renderCache) delete renderCache[k];
  foodBirth.clear();
  keysDown.clear();
  serverBoosting = false;

  lastSent = 0;
  lastDirSent = {x:1,y:0};
  lastAxisX = 1;
  lastAxisY = -1;

  cameraX = 0; cameraY = 0;
  camHX = camHY = null;

  menu.style.display="none";
  canvas.style.display="block";
  hud.style.display="block";

  useTouch = !!isTouchDevice;
  VIEW_ZOOM = isTouchDevice ? MOBILE_VIEW_ZOOM : 1;

  if(useTouch){
    useMouse = false;
    touchUI.style.display = "block";
    touchUI.setAttribute("aria-hidden","false");
  } else {
    touchUI.style.display = "none";
    touchUI.setAttribute("aria-hidden","true");
  }

  fitCanvas();
  canvas.focus();

  playerId="player"+Math.floor(Math.random()*9999);
  ws=new WebSocket(wsUrl(`/ws/${ROOM_ID}/${playerId}`));
  ws.binaryType = "arraybuffer";

  ws.onopen = () => {
    startRttPing();
    startInputHeartbeat();
  };

  ws.onmessage = async (e) => {
    let data = null;

    if(e.data instanceof ArrayBuffer){
      const txt = td.decode(new Uint8Array(e.data));
      data = JSON.parse(txt);
    } else if(typeof e.data === "string") {
      data = JSON.parse(e.data);
    } else {
      return;
    }

    if (data.type === "pong") {
      const now = performance.now();
      const sample = Math.max(0, now - (data.t || now));
      rtt = rtt*0.8 + sample*0.2;
      return;
    }

    if (data.type === "death") {
      dead = true;
      sendBoost(false);
      return;
    }

    if (data.type === "snapshot") {
      const pl = data.players || {};
      for(const id in pl){
        const it = pl[id];
        const r = remote[id] || (remote[id] = { path: [], bodyKF:null, lastV: 0, len: 10, _prevLen:null, boost:0, color:"white", head:null, dir:null, dirS:null, lastNetTs:null, snaps: [] });
        r.color = it.color || r.color;
        r.boost = !!it.boost;
      }
      if (Array.isArray(data.foods)) {
        foods = data.foods;
        markFoodBirths(foods, performance.now());
      }
      return;
    }

    if (data.type === "state" && data.players) {
      const pl = data.players;

      const seen = new Set(Object.keys(pl));
      for(const id in remote){
        if(id === playerId) continue;
        if(!seen.has(id)) delete remote[id];
      }

      const nowMs = performance.now();

      for(const id in pl){
        const it = pl[id];
        const r = remote[id] || (remote[id] = { path: [], bodyKF:null, lastV: 0, len: 10, _prevLen:null, boost:0, color:"white", head:null, dir:null, dirS:null, lastNetTs:null, snaps: [] });

        r.len = it.l|0;
        r.boost = !!it.b;
        r.color = it.c || r.color;

        if(Array.isArray(it.h)) r.head = { x: it.h[0], y: it.h[1] };
        if(Array.isArray(it.u)) r.dir  = { x: it.u[0], y: it.u[1] };

        const hasKF = !!it.kf && Array.isArray(it.body) && it.body.length >= 4;
        let skipPtThisTick = false;

        if (hasKF) {
          r.bodyKF = it.body;
          const kfSnake = snakePointsFromFlatBody(it.body);
          r.path = kfSnake.slice();
          r.lastV = (it.pv | 0);
          pushSnap(r, kfSnake, nowMs);
          skipPtThisTick = true;
        }

        if (!skipPtThisTick && Array.isArray(it.pt) && it.pt.length) {
          const basePrevV = (r.lastV | 0);

          let maxV = (r.lastV | 0);
          const newPts = [];

          for (let j = 0; j < it.pt.length; j++) {
            const n = it.pt[j];
            const v = n[0] | 0;
            if (v <= basePrevV) continue;

            const x = +n[1], y = +n[2];

            if (r.path && r.path.length) {
              const hx = r.path[0].x, hy = r.path[0].y;
              const dx = x - hx, dy = y - hy;
              if (dx*dx + dy*dy < 0.01) {
                if (v > maxV) maxV = v;
                continue;
              }
            }

            newPts.push({ x, y, v });
            if (v > maxV) maxV = v;
          }

          for (let k = newPts.length - 1; k >= 0; k--) {
            r.path.unshift({ x: newPts[k].x, y: newPts[k].y });
          }

          if (r.path.length > REMOTE_PATH_MAX) r.path.length = REMOTE_PATH_MAX;
          r.lastV = maxV;

          let sourcePath = (r.path && r.path.length >= 2) ? r.path : null;
          if(!sourcePath && Array.isArray(r.bodyKF) && r.bodyKF.length >= 4){
            sourcePath = snakePointsFromFlatBody(r.bodyKF);
          }
          if(sourcePath && sourcePath.length >= 2){
            const netSnake = buildSnakeFromPath(sourcePath, r.len);
            pushSnap(r, netSnake, nowMs);
          }
        }

        if(r.dir){
          let ux = r.dir.x, uy = r.dir.y;
          const ul = Math.hypot(ux, uy) || 1;
          ux /= ul; uy /= ul;

          if(!r.dirS){
            r.dirS = { x: ux, y: uy };
          } else {
            const dot = (r.dirS.x * ux + r.dirS.y * uy);
            const a = (dot < 0.80) ? 0.65 : 0.25;
            r.dirS.x = r.dirS.x + (ux - r.dirS.x) * a;
            r.dirS.y = r.dirS.y + (uy - r.dirS.y) * a;
            const sl = Math.hypot(r.dirS.x, r.dirS.y) || 1;
            r.dirS.x /= sl; r.dirS.y /= sl;
          }
        }

        r.lastNetTs = nowMs;
      }

      if (Array.isArray(data.foods)) {
        foods = data.foods;
        markFoodBirths(foods, performance.now());
      }
    }
  };

  ws.onclose=()=>{
    if(rttTimer){ clearInterval(rttTimer); rttTimer = null; }
    if(inputTimer){ clearInterval(inputTimer); inputTimer = null; }
    sendBoost(false);
    touchUI.style.display = "none";
    touchUI.setAttribute("aria-hidden","true");
    setTimeout(()=>{
      canvas.style.display="none";
      hud.style.display="none";
      menu.style.display="flex";
    }, 150);
  };
}

/* INPUT (–ü–ö) */
canvas.addEventListener("mousemove", e=>{
  if(useTouch) return;
  if(!useMouse) return;
  if(dead) return;
  const me = remote[playerId];
  if(!me) return;

  let hx = null, hy = null;
  if(me.path && me.path.length) { hx = me.path[0].x; hy = me.path[0].y; }
  else if(Array.isArray(me.bodyKF) && me.bodyKF.length >= 2) { hx = me.bodyKF[0]; hy = me.bodyKF[1]; }
  if(hx == null) return;

  const mx = (e.clientX / VIEW_ZOOM) + cameraX - hx;
  const my = (e.clientY / VIEW_ZOOM) + cameraY - hy;
  if(Math.abs(mx) + Math.abs(my) < 0.001) return;
  mouseTargetHeading = Math.atan2(my, mx);
});

document.addEventListener("keydown", e=>{
  if(useTouch) return;
  const k = (e.key || "").toLowerCase();
  if(k === "m" || k === "—å"){
    useMouse = !useMouse;
    keysDown.clear();
    mouseTargetHeading = heading;
    e.preventDefault?.();
  }
});

function updateAxisOnPress(k){
  if(k === "a") lastAxisX = -1;
  if(k === "d") lastAxisX =  1;
  if(k === "w") lastAxisY = -1;
  if(k === "s") lastAxisY =  1;
}

document.addEventListener("keydown", e=>{
  if(useTouch) return;
  if(dead) return;
  const k = normKey(e.key);
  if(k === " " || k === "space" || e.code === "Space"){
    sendBoost(true);
    e.preventDefault?.();
    return;
  }
  if(k === "w" || k === "a" || k === "s" || k === "d"){
    if(!keysDown.has(k)){
      keysDown.add(k);
      updateAxisOnPress(k);
    }
    e.preventDefault?.();
  }
});

document.addEventListener("keyup", e=>{
  if(useTouch) return;
  const k = normKey(e.key);
  if(k === " " || k === "space" || e.code === "Space"){
    sendBoost(false);
    e.preventDefault?.();
    return;
  }
  if(k === "w" || k === "a" || k === "s" || k === "d"){
    keysDown.delete(k);
    e.preventDefault?.();
  }
});

window.addEventListener("blur", () => sendBoost(false));
document.addEventListener("visibilitychange", () => { if(document.hidden) sendBoost(false); });

/* INPUT (MOBILE): joystick + boost */
const joy = { active:false, pid:null, radius:48, x:0, y:0 };
function setKnob(dx, dy){ joyKnob.style.transform = `translate(${dx}px, ${dy}px)`; }
function joyReset(){
  joy.active = false; joy.pid = null;
  joy.x = joy.y = 0; setKnob(0,0);
  touchTargetHeading = heading;
}
function joyUpdateFromPointer(clientX, clientY){
  const rect = joyWrap.getBoundingClientRect();
  const cx = rect.left + rect.width/2;
  const cy = rect.top + rect.height/2;
  const dx0 = clientX - cx;
  const dy0 = clientY - cy;
  const r = joy.radius;
  const len = Math.hypot(dx0, dy0);
  let dx = dx0, dy = dy0;
  if(len > r){
    const k = r / len; dx *= k; dy *= k;
  }
  joy.x = dx; joy.y = dy;
  setKnob(dx, dy);
  if(Math.abs(dx) + Math.abs(dy) < 2){
    touchTargetHeading = heading;
    return;
  }
  touchTargetHeading = Math.atan2(dy, dx);
}
joyWrap.addEventListener("pointerdown", (e)=>{
  if(!useTouch) return;
  if(dead) return;
  joy.active = true;
  joy.pid = e.pointerId;
  joyWrap.setPointerCapture(e.pointerId);
  joyUpdateFromPointer(e.clientX, e.clientY);
  e.preventDefault();
});
joyWrap.addEventListener("pointermove", (e)=>{
  if(!useTouch || !joy.active) return;
  if(e.pointerId !== joy.pid) return;
  joyUpdateFromPointer(e.clientX, e.clientY);
  e.preventDefault();
});
function joyEnd(e){
  if(!useTouch || !joy.active) return;
  if(e && e.pointerId != null && e.pointerId !== joy.pid) return;
  joyReset();
  e?.preventDefault?.();
}
joyWrap.addEventListener("pointerup", joyEnd);
joyWrap.addEventListener("pointercancel", joyEnd);
joyWrap.addEventListener("lostpointercapture", joyEnd);

function bindHoldButton(btn, onDown, onUp){
  btn.addEventListener("pointerdown", (e)=>{ if(!useTouch) return; onDown(); btn.setPointerCapture(e.pointerId); e.preventDefault(); });
  btn.addEventListener("pointerup",   (e)=>{ if(!useTouch) return; onUp();   e.preventDefault(); });
  btn.addEventListener("pointercancel",(e)=>{ if(!useTouch) return; onUp();  e.preventDefault(); });
  btn.addEventListener("lostpointercapture",(e)=>{ if(!useTouch) return; onUp(); e.preventDefault(); });
}
bindHoldButton(boostBtn, ()=>sendBoost(true), ()=>sendBoost(false));

/* START */
playBtn.addEventListener("click", startGame);
fitCanvas();
requestAnimationFrame(draw);
</script>
</body>
</html>
